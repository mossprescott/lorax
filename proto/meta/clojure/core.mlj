; Grammar/presentation for the 'core' language of Clojure, which is reducible 
; to the kernel language.

; This version uses the higher-level "grammar" language, which specifies structure as 
; well as a presentation reduction, and which can be reduced/compiled down into both a
; regular structure program and a presentation reduction.

(use 'meta.core)  ; ignored by load-nodes, but should make this file legal Clojure

(make-node :grammar/language [
    ; program
    (make-node :grammar/seqNode {
      :type 
      (make-node :grammar/type :clojure/core/program)
      
      :supers 
      (make-node :grammar/types [])

      :options 
      (make-node :grammar/options [
        (make-node :grammar/node {
          :type :clojure/core/doc
        })
        (make-node :grammar/node {
          :type :clojure/kernel/expr
        })
      ])
      
      :min
      (make-node :grammar/count 0)
          
      :display
      (make-node :grammar/seq {
        :type 
        (make-node :grammar/type :view/section)
        
        :separator
        (make-node :view/expr/keyword { :str " " })
      })
    })

    ; session
    (make-node :grammar/seqNode {
      :type 
      (make-node :grammar/type :clojure/core/session)
      
      :supers 
      (make-node :grammar/types [])

      :options 
      (make-node :grammar/options [
        (make-node :grammar/node {
          :type :clojure/core/exchange
        })
      ])
      
      :min 
      (make-node :grammar/count 0)
          
      :display
      (make-node :grammar/seq {
        :type 
        (make-node :grammar/type :view/section)
        
        :separator
        (make-node :view/expr/keyword { :str " " })
      })
    })

    ; exchange
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/core/exchange)
      
      :supers 
      (make-node :grammar/types [
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :exchange_expr {
          :name
          (make-node :grammar/name :clojure/core/exchange/expr)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type
                :clojure/kernel/expr
              })
          ])
          
          :optional false
        }) 
        (make-node :grammar/attr :exchange_kernel {
          :name
          (make-node :grammar/name :clojure/core/exchange/kernel)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type
                :clojure/kernel/expr
              })
          ])
          
          :optional true
        }) 
        (make-node :grammar/attr :exchange_value {
          :name
          (make-node :grammar/name :clojure/core/exchange/value)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
          
          :optional false
        }) 
      ])
      
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/section [
          (make-node :view/sequence [
            (make-node :view/expr/mono { :str "$" })
            (make-node :view/quad)
            (make-node :clojure/kernel/unquote {
              :body 
              (make-node :clojure/kernel/var {
                :ref (ref-node :exchange_expr)
              })
            })
          ])
          ; Note: big scary conditional to handle an optional attribute:
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/if {
              :test
              (make-node :clojure/kernel/app {
                :expr
                (make-node :clojure/kernel/extern { :name "="})
                
                :args
                (make-node :clojure/kernel/args [
                  (make-node :clojure/kernel/app {
                    :expr
                    (make-node :clojure/kernel/extern { :name "meta.core/node-type"})
                
                    :args
                    (make-node :clojure/kernel/args [
                      (make-node :clojure/kernel/var {
                        :ref (ref-node :exchange_kernel)
                      })
                    ])
                  })
                  (make-node :clojure/kernel/name { :value :view/expr/missing })
                ])
              })
              
              :then
              (make-node :clojure/kernel/quote {
                :body
                (make-node :view/sequence []) ; HACK: empty
              })
              
              :else
              (make-node :clojure/kernel/quote {
                :body
                (make-node :view/sequence [
                  (make-node :view/expr/mono { :str " " })
                  (make-node :view/quad)
                  (make-node :clojure/core/comment {
                    :expr
                    (make-node :clojure/kernel/unquote {
                      :body 
                      (make-node :clojure/kernel/var {
                        :ref (ref-node :exchange_kernel)
                      })
                    })
                  })
                ])
              })
            })
          })
          (make-node :view/sequence [
            (make-node :view/expr/symbol { :str :to })
            (make-node :view/quad)
            (make-node :clojure/kernel/unquote {
              :body 
              (make-node :clojure/kernel/var {
                :ref (ref-node :exchange_value)
              })
            })
          ])
        ])
      })
    })

    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/core/doc)
      
      :supers 
      (make-node :grammar/types [])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :doc_string {
          :name
          (make-node :grammar/name :clojure/core/doc/string)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/string)
          ])
        })
      ])
      
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/expr/doc {
;        (make-node :view/chars {  ; Note: this is the right reduction, but doesn't render properly via the meta-expr reduction
          :str
          (make-node :clojure/kernel/unquote {
            :body
            ; (make-node :clojure/kernel/app {
            ;   :expr
            ;   (make-node :clojure/kernel/extern { :name "meta.core/node-value" })
            ;   
            ;   :args
            ;   (make-node :clojure/kernel/args [
                (make-node :clojure/kernel/var {
                  :ref (ref-node :doc_string)
                })
            ;   ])
            ; })
          })
          
;          :font :times
          
;          :view/drawable/color
;          (make-node :view/gray { :brightness 0.5 })
        })
      })
    })

    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/core/comment)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :clojure/kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :comment_expr {
          :name
          (make-node :grammar/name :clojure/core/comment/expr)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/border {
          :weight 1
          :margin 3
          
          :view/drawable/colors 
          (make-node :core/seq [ 
            (make-node :view/rgb { :red 0.7 :green 0.7 :blue 0.7 })
          ])
   
          :fill
          (make-node :view/rgb { :red 0.9 :green 0.9 :blue 0.9 })
          
          :item
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :comment_expr)
            })
          })
        })
      })
  
      :expand
      (make-node :clojure/kernel/quote {
        :body
        (make-node :clojure/kernel/nil)
      })
    })
  
    ; not
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/core/not)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :clojure/kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :not_expr {
          :name
          (make-node :grammar/name :clojure/core/not/expr)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/expr/juxt [
          (make-node :view/expr/symbol { :str :neg })
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :not_expr)
            })
          })
        ])
      })
  
      :expand
      (make-node :clojure/kernel/quote {
        :body
        (make-node :clojure/kernel/if {
          :test
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :not_expr)
            })
          })
      
          :then
          (make-node :clojure/kernel/false)
      
          :else
          (make-node :clojure/kernel/true)
        })
      })
    })
  
    ; unaryminus
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/core/unaryminus)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :clojure/kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :unaryminus_expr {
          :name
          (make-node :grammar/name :clojure/core/unaryminus/expr)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/expr/juxt [
          (make-node :view/expr/symbol { :str "-" })
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :unaryminus_expr)
            })
          })
        ])
      })
  
      :expand
      (make-node :clojure/kernel/quote {
        :body
        (make-node :clojure/kernel/app {
          :expr
          (make-node :clojure/kernel/extern { :name "-" })
          
          :args
          (make-node :clojure/kernel/args [
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :unaryminus_expr)
              })
            })
          ])
        })
      })
    })

    ; sqrt
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/core/sqrt)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :clojure/kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :sqrt_expr {
          :name
          (make-node :grammar/name :clojure/core/sqrt/expr)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/radical {
          :radicand
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :sqrt_expr)
            })
          })
        })
      })
  
      :expand
      (make-node :clojure/kernel/quote {
        :body
        (make-node :clojure/kernel/app {
          :expr
          (make-node :clojure/kernel/extern { :name "Math/sqrt" })
          
          :args
          (make-node :clojure/kernel/args [
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :sqrt_expr)
              })
            })
          ])
        })
      })
    })

    ; plus
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/core/plus)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :clojure/kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :plus_left {
          :name
          (make-node :grammar/name :clojure/core/plus/left)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
        })
        (make-node :grammar/attr :plus_right {
          :name
          (make-node :grammar/name :clojure/core/plus/right)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/expr/relation [
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :plus_left)
            })
          })
          (make-node :view/expr/symbol { :str "+" })
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :plus_right)
            })
          })
        ])
      })
  
      :expand
      (make-node :clojure/kernel/quote {
        :body
        (make-node :clojure/kernel/app {
          :expr
          (make-node :clojure/kernel/extern { :name "+" })
          
          :args
          (make-node :clojure/kernel/args [
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :plus_left)
              })
            })
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :plus_right)
              })
            })
          ])
        })
      })
    })

    ; minus
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/core/minus)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :clojure/kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :minus_left {
          :name
          (make-node :grammar/name :clojure/core/minus/left)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
        })
        (make-node :grammar/attr :minus_right {
          :name
          (make-node :grammar/name :clojure/core/minus/right)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/expr/relation [
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :minus_left)
            })
          })
          (make-node :view/expr/symbol { :str "-" })
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :minus_right)
            })
          })
        ])
      })
  
      :expand
      (make-node :clojure/kernel/quote {
        :body
        (make-node :clojure/kernel/app {
          :expr
          (make-node :clojure/kernel/extern { :name "-" })
          
          :args
          (make-node :clojure/kernel/args [
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :minus_left)
              })
            })
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :minus_right)
              })
            })
          ])
        })
      })
    })

    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/core/times)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :clojure/kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :times_left {
          :name
          (make-node :grammar/name :clojure/core/times/left)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
        })
        (make-node :grammar/attr :times_right {
          :name
          (make-node :grammar/name :clojure/core/times/right)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/expr/binary [
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :times_left)
            })
          })
          (make-node :view/expr/symbol { :str :times })
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :times_right)
            })
          })
        ])
      })
  
      :expand
      (make-node :clojure/kernel/quote {
        :body
        (make-node :clojure/kernel/app {
          :expr
          (make-node :clojure/kernel/extern { :name "*" })
          
          :args
          (make-node :clojure/kernel/args [
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :times_left)
              })
            })
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :times_right)
              })
            })
          ])
        })
      })
    })

    ; greater
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/core/greater)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :clojure/kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :greater_left {
          :name
          (make-node :grammar/name :clojure/core/greater/left)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
        })
        (make-node :grammar/attr :greater_right {
          :name
          (make-node :grammar/name :clojure/core/greater/right)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/expr/relation [
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :greater_left)
            })
          })
          (make-node :view/expr/symbol { :str ">" })
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :greater_right)
            })
          })
        ])
      })
  
      :expand
      (make-node :clojure/kernel/quote {
        :body
        (make-node :clojure/kernel/app {
          :expr
          (make-node :clojure/kernel/extern { :name ">" })
          
          :args
          (make-node :clojure/kernel/args [
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :greater_left)
              })
            })
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :greater_right)
              })
            })
          ])
        })
      })
    })

    ; equal
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/core/equal)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :clojure/kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :equal_left {
          :name
          (make-node :grammar/name :clojure/core/equal/left)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
        })
        (make-node :grammar/attr :equal_right {
          :name
          (make-node :grammar/name :clojure/core/equal/right)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/expr/relation [
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :equal_left)
            })
          })
          (make-node :view/expr/symbol { :str "=" })
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :equal_right)
            })
          })
        ])
      })
  
      :expand
      (make-node :clojure/kernel/quote {
        :body
        (make-node :clojure/kernel/app {
          :expr
          (make-node :clojure/kernel/extern { :name "=" })
          
          :args
          (make-node :clojure/kernel/args [
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :equal_left)
              })
            })
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :equal_right)
              })
            })
          ])
        })
      })
    })

    ; :fraction
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/core/fraction)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :clojure/kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :fraction_num {
          :name
          (make-node :grammar/name :clojure/core/fraction/num)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
        })
        (make-node :grammar/attr :fraction_denom {
          :name
          (make-node :grammar/name :clojure/core/fraction/denom)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/over {
          :top
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :fraction_num)
            })
          })
          
          :weight 1
          
          :bottom
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :fraction_denom)
            })
          })
        })
      })
  
      :expand
      (make-node :clojure/kernel/quote {
        :body
        (make-node :clojure/kernel/app {
          :expr
          (make-node :clojure/kernel/extern { :name "/" })
          
          :args
          (make-node :clojure/kernel/args [
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :fraction_num)
              })
            })
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :fraction_denom)
              })
            })
          ])
        })
      })
    })

    ; "square" expr: using simple multiplication, so it works on integers, 
    ; ratios, etc., unlike Java's pow() fn, which always gives you a double
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/core/square)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :clojure/kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :square_expr {
          :name
          (make-node :grammar/name :clojure/core/square/expr)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
        })
      ])
    
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/scripted {
          :nucleus
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :square_expr)
            })
          })
          
          :super
          (make-node :view/expr/int { :str "2" })
        })
      })
      
      :expand
      (make-node :clojure/kernel/quote {
        :body
        (make-node :clojure/kernel/let {
          :bind
          (make-node :clojure/kernel/bind :n_square {})
          
          :expr
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :square_expr)
            })
          })
          
          :body
          (make-node :clojure/core/times {
            :left
            (make-node :clojure/kernel/var {
              :ref (ref-node :n_square)
            })
            
            :right
            (make-node :clojure/kernel/var {
              :ref (ref-node :n_square)
            })
          })
        })
      })
    })

    ;
    ; Some operators on nodes, for use in grammars (and meta-programs, I guess):
    ;
    
  ; attr
  (make-node :grammar/mapNode {
    :type
    (make-node :grammar/type :clojure/core/attr)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :clojure/kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :attr_node {
        :name
        (make-node :grammar/name :clojure/core/attr/node)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :clojure/kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :attr_name {
        :name
        (make-node :grammar/name :clojure/core/attr/name)
      
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :clojure/kernel/expr })
        ])
      
        :optional false
      }) 
    ])
    
    :display
    (make-node :clojure/kernel/quote {
      :body
      (make-node :view/expr/juxt [
        (make-node :view/expr/keyword { :str "attr" })
        (make-node :view/delimited {
          :left "["
          :right "]"
          :content
          (make-node :view/sequence [
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
               :ref (ref-node :attr_node) 
              })
            })
            (make-node :view/expr/int { :str "," })
            (make-node :view/mediumspace)
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
               :ref (ref-node :attr_name) 
              })
            })
          ])
        })
      ])
    })
    
    :expand
    (make-node :clojure/kernel/quote {
      :body
      (make-node :clojure/kernel/app {
        :expr
        (make-node :clojure/kernel/extern { :name "meta.core/node-attr" })
        
        :args
        (make-node :clojure/kernel/args [
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
             :ref (ref-node :attr_node) 
            })
          })
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
             :ref (ref-node :attr_name) 
            })
          })
        ])
      })
    })
  })
  
  ; type
  (make-node :grammar/mapNode {
    :type
    (make-node :grammar/type :clojure/core/type)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :clojure/kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :type_node {
        :name
        (make-node :grammar/name :clojure/core/type/node)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :clojure/kernel/expr })
        ])
        
        :optional false
      }) 
    ])
    
    :display
    (make-node :clojure/kernel/quote {
      :body
      (make-node :view/expr/juxt [
        (make-node :view/expr/keyword { :str "type" })
        (make-node :view/delimited {
          :left "["
          :right "]"
          :content
          (make-node :view/sequence [
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
               :ref (ref-node :type_node) 
              })
            })
          ])
        })
      ])
    })
    
    :expand
    (make-node :clojure/kernel/quote {
      :body
      (make-node :clojure/kernel/app {
        :expr
        (make-node :clojure/kernel/extern { :name "meta.core/node-type" })
        
        :args
        (make-node :clojure/kernel/args [
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
             :ref (ref-node :type_node) 
            })
          })
        ])
      })
    })
  })
  
  ; eval
  (make-node :grammar/mapNode {
    :type
    (make-node :grammar/type :clojure/core/eval)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :clojure/kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :eval_node {
        :name
        (make-node :grammar/name :clojure/core/eval/node)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :clojure/kernel/expr })
        ])
        
        :optional false
      }) 
    ])
    
    :display
    (make-node :clojure/kernel/quote {
      :body
      (make-node :view/expr/juxt [
        (make-node :view/expr/keyword { :str "eval" })
        (make-node :view/delimited {
          :left "["
          :right "]"
          :content
          (make-node :view/sequence [
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
               :ref (ref-node :eval_node) 
              })
            })
          ])
        })
      ])
    })
    
    :expand
    (make-node :clojure/kernel/quote {
      :body
      (make-node :clojure/kernel/app {
        :expr
        (make-node :clojure/kernel/extern { :name "meta.clojure.kernel/meta-eval" })
        
        :args
        (make-node :clojure/kernel/args [
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
             :ref (ref-node :eval_node) 
            })
          })
        ])
      })
    })
  })
  
    ; value: but probably what I actually want is eval?
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/core/value)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :clojure/kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :value_expr {
          :name
          (make-node :grammar/name :clojure/core/value/expr)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
        })
      ])
    
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/expr/juxt [
          (make-node :view/expr/keyword { :str "value" })
          (make-node :view/delimited { 
            :left "["
            :right "]"
            :content
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :value_expr)
              })
            })
          })
        ])
      })
      
      :expand
      (make-node :clojure/kernel/quote {
        :body
        (make-node :clojure/kernel/app {
          :expr
          (make-node :clojure/kernel/extern { :name "meta.core/node-value" })
          
          :args
          (make-node :clojure/kernel/args [
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :value_expr)
              })
            })
          ])
        })
      })
    })

    ; ; binary AND
    ; (node :grammar/rule
    ;   :type
    ;   :clojure/core/and
    ;   
    ;   :supers [ :clojure/kernel/expr ]
    ;   
    ;   :display  ; TODO: quote it?
    ;   (node :view/expr/relation
    ;     :boxes [
    ;       (node :grammar/attr :core/id :left
    ;         :name 
    ;         :clojure/core/and/left
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :clojure/kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;       (node :view/expr/keyword :str "and")
    ;       (node :grammar/attr :core/id :right
    ;         :name 
    ;         :clojure/core/and/right
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :clojure/kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;     ])
    ;     
    ;     :expand
    ;     (node :clojure/kernel/quote
    ;       :body
    ;       (node :clojure/kernel/let
    ;         :bind 
    ;         (node :clojure/kernel/bind :core/id :l)
    ;         
    ;         :expr
    ;         (node :clojure/kernel/unquote
    ;           :body
    ;           (node :clojure/kernel/var 
    ;             :ref (ref-node :left)))
    ;         
    ;         :body
    ;         (node :clojure/kernel/if
    ;           :test
    ;           (node :clojure/core/not 
    ;             :expr
    ;             (node :clojure/kernel/var 
    ;               :ref (ref-node :l)))
    ;           
    ;           :then
    ;           (node :clojure/kernel/var 
    ;             :ref (ref-node :l))
    ;           
    ;           :else
    ;           (node :clojure/kernel/unquote
    ;             :body
    ;             (node :clojure/kernel/var 
    ;               :ref (ref-node :right)))))))
    ;     
    ; ; TODO: OR
    ;     
    ; ; binary +
    ; (node :grammar/rule
    ;   :type
    ;   :clojure/core/plus
    ;   
    ;   :supers [ :clojure/kernel/expr ]
    ;   
    ;   :display  ; TODO: quote it?
    ;   (node :view/expr/binary
    ;     :boxes [
    ;       (node :grammar/attr :core/id :left2
    ;         :name 
    ;         :clojure/core/plus/left
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :clojure/kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;       (node :view/expr/symbol :str "+")
    ;       (node :grammar/attr :core/id :right2
    ;         :name 
    ;         :clojure/core/plus/right
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :clojure/kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;     ])
    ;     
    ;     :expand
    ;     (node :clojure/kernel/quote
    ;       :body
    ;       (node :clojure/kernel/app
    ;         :expr 
    ;         (node :clojure/kernel/extern :name "+")
    ;         
    ;         :args [
    ;           (node :clojure/kernel/unquote
    ;             :body
    ;             (node :clojure/kernel/var 
    ;               :ref (ref-node :left2)))
    ;           
    ;           (node :clojure/kernel/unquote
    ;             :body
    ;             (node :clojure/kernel/var 
    ;               :ref (ref-node :right2)))
    ;         ])))
    ; 
    ; ; binary -
    ; (node :grammar/rule
    ;   :type
    ;   :clojure/core/minus
    ;   
    ;   :supers [ :clojure/kernel/expr ]
    ;   
    ;   :display  ; TODO: quote it?
    ;   (node :view/expr/binary
    ;     :boxes [
    ;       (node :grammar/attr :core/id :left3
    ;         :name 
    ;         :clojure/core/minus/left
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :clojure/kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;       (node :view/expr/symbol :str "-")
    ;       (node :grammar/attr :core/id :right3
    ;         :name 
    ;         :clojure/core/minus/right
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :clojure/kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;     ])
    ;     
    ;     :expand
    ;     (node :clojure/kernel/quote
    ;       :body
    ;       (node :clojure/kernel/app
    ;         :expr 
    ;         (node :clojure/kernel/extern :name "-")
    ;         
    ;         :args [
    ;           (node :clojure/kernel/unquote
    ;             :body
    ;             (node :clojure/kernel/var 
    ;               :ref (ref-node :left3)))
    ;           
    ;           (node :clojure/kernel/unquote
    ;             :body
    ;             (node :clojure/kernel/var 
    ;               :ref (ref-node :right3)))
    ;         ])))
    ; 
    ; ; binary *
    ; (node :grammar/rule
    ;   :type
    ;   :clojure/core/times
    ;   
    ;   :supers [ :clojure/kernel/expr ]
    ;   
    ;   :display  ; TODO: quote it?
    ;   (node :view/expr/binary
    ;     :boxes [
    ;       (node :grammar/attr :core/id :left4
    ;         :name 
    ;         :clojure/core/times/left
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :clojure/kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;       (node :view/expr/symbol :str :times)
    ;       (node :grammar/attr :core/id :right4
    ;         :name 
    ;         :clojure/core/times/right
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :clojure/kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;     ])
    ;     
    ;     :expand
    ;     (node :clojure/kernel/quote
    ;       :body
    ;       (node :clojure/kernel/app
    ;         :expr 
    ;         (node :clojure/kernel/extern :name "*")
    ;         
    ;         :args [
    ;           (node :clojure/kernel/unquote
    ;             :body
    ;             (node :clojure/kernel/var 
    ;               :ref (ref-node :left4)))
    ;           
    ;           (node :clojure/kernel/unquote
    ;             :body
    ;             (node :clojure/kernel/var 
    ;               :ref (ref-node :right4)))
    ;         ])))
    ; 
    ; ; binary >
    ; (node :grammar/rule
    ;   :type
    ;   :clojure/core/greater
    ;   
    ;   :supers [ :clojure/kernel/expr ]
    ;   
    ;   :display  ; TODO: quote it?
    ;   (node :view/expr/relation
    ;     :boxes [
    ;       (node :grammar/attr :core/id :left5
    ;         :name 
    ;         :clojure/core/greater/left
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :clojure/kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;       (node :view/expr/symbol :str ">")
    ;       (node :grammar/attr :core/id :right5
    ;         :name 
    ;         :clojure/core/greater/right
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :clojure/kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;     ])
    ;     
    ;     :expand
    ;     (node :clojure/kernel/quote
    ;       :body
    ;       (node :clojure/kernel/app
    ;         :expr 
    ;         (node :clojure/kernel/extern :name ">")
    ;         
    ;         :args [
    ;           (node :clojure/kernel/unquote
    ;             :body
    ;             (node :clojure/kernel/var 
    ;               :ref (ref-node :left5)))
    ;           
    ;           (node :clojure/kernel/unquote
    ;             :body
    ;             (node :clojure/kernel/var 
    ;               :ref (ref-node :right5)))
    ;         ])))
    ; 
    ; ; TODO: >=, <, <=, =, !=
    ; 
    ; 
    ; 
    ; ;
    ; ; Sequences
    ; ;
    ; 
    ; ; Sequence (list) constructor:
    ; (node :grammar/rule
    ;   :type
    ;   :clojure/core/sequence
    ;   
    ;   :supers [ :clojure/kernel/expr ]
    ;   
    ;   :display
    ;   (node :view/sequence
    ;     :items
    ;     (node :grammar/sequence :core/id :items1
    ;       :name 
    ;       :clojure/core/sequence/items
    ;       
    ;       :options [
    ;         (node :structure/node
    ;           :type :clojure/kernel/expr)
    ;       ]
    ;       
    ;       :min 0
    ;       
    ;       :separator
    ;       (node :view/sequence
    ;         :items [
    ;           (node :view/expr/keyword :str ",")
    ;           (node :view/thickspace)
    ;         ])))
    ;   
    ;   :expand
    ;   (node :clojure/kernel/quote
    ;     :body
    ;     (node :clojure/kernel/app
    ;       :expr
    ;       (node :clojure/kernel/extern
    ;         :name "list")
    ;         
    ;       :args
    ;       (node :clojure/kernel/unquote
    ;         :body
    ;         (node :clojure/kernel/var
    ;           :ref (ref-node :items1))))))
    ; 
    ; ; cons(), as "."
    ; (node :grammar/rule
    ;   :type 
    ;   :clojure/core/cons
    ;   
    ;   :supers [ :clojure/kernel/expr ]
    ;   
    ;   :display
    ;   (node :view/expr/relation
    ;     :boxes [
    ;       (node :grammar/attr :core/id :first0
    ;         :name 
    ;         :clojure/core/cons/first
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :clojure/kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;       (node :view/expr/symbol :str ".")
    ;       (node :grammar/attr
    ;         :name 
    ;         :clojure/core/cons/rest :core/id :rest0
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :clojure/kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;     ])
    ;   
    ;   :expand
    ;   (node :clojure/kernel/quote
    ;     :body
    ;     (node :clojure/kernel/app
    ;       :expr
    ;       (node :clojure/kernel/extern
    ;         :name "cons")
    ;       
    ;       :args [
    ;         (node :clojure/kernel/unquote
    ;           :body
    ;           (node :clojure/kernel/var
    ;             :ref (ref-node :first0)))
    ;         (node :clojure/kernel/unquote
    ;           :body
    ;           (node :clojure/kernel/var
    ;             :ref (ref-node :rest0)))
    ;       ])))
    ; 
    ; ; first(coll)
    ; (node :grammar/rule
    ;   :type
    ;   :clojure/core/first
    ;   
    ;   :supers [ :clojure/kernel/expr ]
    ;   
    ;   :display
    ;   (node :view/expr/juxt
    ;     :boxes [
    ;       (node :view/expr/keyword :str "first")
    ;       (node :view/parens
    ;         :left "["
    ;         :right "]"
    ;         
    ;         :content
    ;         (node :grammar/attr :core/id :coll1
    ;           :name
    ;           :clojure/core/first/coll
    ;           
    ;           :options [
    ;             (node :structure/node
    ;               :type :clojure/kernel/expr)
    ;           ]
    ;           
    ;           :optional false))
    ;     ])
    ;   
    ;   :expand
    ;   (node :clojure/kernel/quote
    ;     :body
    ;     (node :clojure/kernel/app
    ;       :expr
    ;       (node :clojure/kernel/extern
    ;         :name "first")
    ;       
    ;       :args [
    ;         (node :clojure/kernel/unquote
    ;           :body
    ;           (node :clojure/kernel/var
    ;             :ref (ref-node :coll1)))
    ;       ])))
    ; 
    ; ; rest(coll)
    ; (node :grammar/rule
    ;   :type
    ;   :clojure/core/rest
    ;   
    ;   :supers [ :clojure/kernel/expr ]
    ;   
    ;   :display
    ;   (node :view/expr/juxt
    ;     :boxes [
    ;       (node :view/expr/keyword :str "rest")
    ;       (node :view/parens
    ;         :left "["
    ;         :right "]"
    ;         
    ;         :content
    ;         (node :grammar/attr :core/id :coll2
    ;           :name
    ;           :clojure/core/rest/coll
    ;           
    ;           :options [
    ;             (node :structure/node
    ;               :type :clojure/kernel/expr)
    ;           ]
    ;           
    ;           :optional false))
    ;     ])
    ;   
    ;   :expand
    ;   (node :clojure/kernel/quote
    ;     :body
    ;     (node :clojure/kernel/app
    ;       :expr
    ;       (node :clojure/kernel/extern
    ;         :name "rest")
    ;       
    ;       :args [
    ;         (node :clojure/kernel/unquote
    ;           :body
    ;           (node :clojure/kernel/var
    ;             :ref (ref-node :coll2)))
    ;       ])))
    ; 
    ; ; subscript
    ; (node :grammar/rule
    ;   :type
    ;   :clojure/core/nth
    ;   
    ;   :supers [ :clojure/kernel/expr ]
    ;   
    ;   :display
    ;   (node :view/expr/juxt
    ;     :boxes [
    ;       (node :grammar/attr :core/id :coll0
    ;         :name
    ;         :clojure/core/nth/coll
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :clojure/kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;       (node :view/parens
    ;         :left "["
    ;         :right "]"
    ;         
    ;         :content
    ;         (node :grammar/attr :core/id :index0
    ;           :name
    ;           :clojure/core/nth/index
    ;         
    ;           :options [
    ;             (node :structure/node
    ;               :type :clojure/kernel/expr)
    ;           ]
    ;         
    ;           :optional false))
    ;     ])
    ;   
    ;   :expand
    ;   (node :clojure/kernel/quote
    ;     :body
    ;     (node :clojure/kernel/app
    ;       :expr
    ;       (node :clojure/kernel/extern
    ;         :name "nth")
    ;       
    ;       :args [
    ;         (node :clojure/kernel/unquote
    ;           :body
    ;           (node :clojure/kernel/var
    ;             :ref (ref-node :coll0)))
    ;         (node :clojure/kernel/unquote
    ;           :body
    ;           (node :clojure/kernel/var
    ;             :ref (ref-node :index0)))
    ;       ])))
    ; 
    ; 
    ; (node :grammar/rule
    ;   :type
    ;   :clojure/core/set
    ;   
    ;   :supers [ :clojure/kernel/expr ]
    ;   
    ;   :display
    ;   (node :view/parens
    ;     :left "{"
    ;     :right "}"
    ;     
    ;     :content
    ;     (node :grammar/attr :core/id :coll5
    ;       :name 
    ;       :clojure/core/set/coll
    ;       
    ;       :options [
    ;           (node :structure/node
    ;             :type :clojure/kernel/expr)          
    ;       ]
    ;       
    ;       :optional false))
    ;     
    ;     :expand
    ;     (node :clojure/kernel/quote
    ;       :body
    ;       (node :clojure/kernel/app
    ;         :expr
    ;         (node :clojure/kernel/extern
    ;           :name "set")
    ;           
    ;         :args [
    ;           (node :clojure/kernel/unquote
    ;             :body
    ;             (node :clojure/kernel/var
    ;               :ref (ref-node :coll5)))
    ;         ])))
    ; 
    ; ; in (contains?):
    ; (node :grammar/rule
    ;   :type
    ;   :clojure/core/in
    ;   
    ;   :supers [ :clojure/kernel/expr ]
    ;   
    ;   :display  ; TODO: quote it?
    ;   (node :view/expr/relation
    ;     :boxes [
    ;       (node :grammar/attr :core/id :elem6
    ;         :name 
    ;         :clojure/core/in/item
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :clojure/kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;       (node :view/expr/symbol :str :in)
    ;       (node :grammar/attr :core/id :coll6
    ;         :name 
    ;         :clojure/core/in/set
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :clojure/kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;     ])
    ;     
    ;     :expand
    ;     (node :clojure/kernel/quote
    ;       :body
    ;       (node :clojure/kernel/app
    ;         :expr 
    ;         (node :clojure/kernel/extern :name "contains?")
    ;         
    ;         :args [
    ;           (node :clojure/kernel/unquote
    ;             :body
    ;             (node :clojure/kernel/var 
    ;               :ref (ref-node :elem6)))
    ;           
    ;           (node :clojure/kernel/unquote
    ;             :body
    ;             (node :clojure/kernel/var 
    ;               :ref (ref-node :coll6)))
    ;         ])))
    ; 
    ; ; postfix factorial (not really a "core" thing, but interesting?)
    ; (node :grammar/rule
    ;   :type
    ;   :clojure/core/factorial
    ;   
    ;   :supers [ :clojure/kernel/expr ]
    ;   
    ;   :display
    ;   (node :view/expr/juxt
    ;     :boxes [
    ;       (node :grammar/attr :core/id :e3
    ;         :name
    ;         :clojure/core/factorial/expr
    ;       
    ;         :options [
    ;           (node :structure/node
    ;             :type :clojure/kernel/expr)
    ;         ]
    ;       
    ;         :optional false)
    ;       (node :view/expr/symbol :str "!")
    ;     ])
    ;     
    ;   :expand
    ;   (node :clojure/kernel/quote
    ;     :body
    ;     (node :clojure/kernel/let
    ;       :bind 
    ;       (node :clojure/kernel/bind :core/id :fact)
    ;       
    ;       :expr
    ;       (node :clojure/kernel/lambda :core/id :factr
    ;         :params [
    ;           (node :clojure/kernel/bind :core/id :n1)
    ;         ]
    ;         
    ;         :body
    ;         (node :clojure/kernel/if
    ;           :test
    ;           (node :clojure/core/greater
    ;             :left
    ;             (node :clojure/kernel/var
    ;               :ref (ref-node :n1))
    ;             
    ;             :right
    ;             (node :clojure/kernel/int :value 1))
    ;             
    ;           :then
    ;           (node :clojure/core/times
    ;             :left
    ;             (node :clojure/kernel/var
    ;               :ref (ref-node :n1))
    ;               
    ;             :right
    ;             (node :clojure/kernel/app
    ;               :expr
    ;               (node :clojure/kernel/var 
    ;                 :ref (ref-node :factr))
    ;                 
    ;               :args [
    ;                 (node :clojure/core/minus
    ;                   :left 
    ;                   (node :clojure/kernel/var
    ;                     :ref (ref-node :n1))
    ;                   
    ;                   :right
    ;                   (node :clojure/kernel/int :value 1))
    ;               ]))
    ;             
    ;             :else
    ;             (node :clojure/kernel/int :value 1)))
    ;       
    ;       :body
    ;       (node :clojure/kernel/app
    ;         :expr
    ;         (node :clojure/kernel/var
    ;           :ref (ref-node :fact))
    ;       
    ;         :args [
    ;           (node :clojure/kernel/unquote
    ;             :body
    ;             (node :clojure/kernel/var
    ;               :ref (ref-node :e3)))
    ;         ]))))
    ;
  
])
