; Grammar/presentation for the 'core' language of Clojure, which is reducible 
; to the kernel language.

; This version uses the higher-level "grammar" language, which specifies structure as 
; well as a presentation reduction, and which can be reduced/compiled down into both a
; regular structure program and a presentation reduction.

(use 'meta.core)  ; ignored by load-nodes, but should make this file legal Clojure

(make-node :grammar/language [
    ; program
    (make-node :grammar/seqNode {
      :type 
      (make-node :grammar/type :core/program)
      
      :supers 
      (make-node :grammar/types [])

      :options 
      (make-node :grammar/options [
        (make-node :grammar/node {
          :type :core/doc
        })
        (make-node :grammar/node {
          :type :kernel/expr
        })
      ])
      
      :min
      (make-node :grammar/count 0)
          
      :display
      (make-node :grammar/seq {
        :type 
        (make-node :grammar/type :view/section)
        
        :separator
        (make-node :view/expr/keyword { :str " " })
      })
    })

    ; session
    (make-node :grammar/seqNode {
      :type 
      (make-node :grammar/type :core/session)
      
      :supers 
      (make-node :grammar/types [])

      :options 
      (make-node :grammar/options [
        (make-node :grammar/node {
          :type :core/exchange
        })
      ])
      
      :min 
      (make-node :grammar/count 0)
          
      :display
      (make-node :grammar/seq {
        :type 
        (make-node :grammar/type :view/section)
        
        :separator
        (make-node :view/expr/keyword { :str " " })
      })
    })

    ; exchange
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :core/exchange)
      
      :supers 
      (make-node :grammar/types [
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :exchange_expr {
          :name
          (make-node :grammar/name :core/exchange/expr)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type
                :kernel/expr
              })
          ])
          
          :optional false
        }) 
        (make-node :grammar/attr :exchange_kernel {
          :name
          (make-node :grammar/name :core/exchange/kernel)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type
                :kernel/expr
              })
          ])
          
          :optional true
        }) 
        (make-node :grammar/attr :exchange_value {
          :name
          (make-node :grammar/name :core/exchange/value)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
          
          :optional false
        }) 
      ])
      
      :display
      (make-node :kernel/quote {
        :body
        (make-node :view/section [
          (make-node :view/sequence [
            (make-node :view/expr/mono { :str "$" })
            (make-node :view/quad)
            (make-node :kernel/unquote {
              :body 
              (make-node :kernel/var {
                :ref (ref-node :exchange_expr)
              })
            })
          ])
          ; Note: big scary conditional to handle an optional attribute:
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/if {
              :test
              ; (make-node :kernel/app {
              ;   :expr
              ;   (make-node :kernel/extern { :name "="})
              ;   
              ;   :args
              ;   (make-node :kernel/args [
              ;     (make-node :kernel/app {
              ;       :expr
              ;       (make-node :kernel/extern { :name "meta.core/node-type"})
              ;   
              ;       :args
              ;       (make-node :kernel/args [
              (make-node :core/missing? {
                :node
                      (make-node :kernel/var {
                        :ref (ref-node :exchange_kernel)
                      })
              })
              ;       ])
              ;     })
              ;     (make-node :kernel/name { :value :view/expr/missing })
              ;   ])
              ; })
              
              :then
              (make-node :kernel/quote {
                :body
                (make-node :view/sequence []) ; HACK: empty
              })
              
              :else
              (make-node :kernel/quote {
                :body
                (make-node :view/sequence [
                  (make-node :view/expr/mono { :str " " })
                  (make-node :view/quad)
                  (make-node :core/comment {
                    :expr
                    (make-node :kernel/unquote {
                      :body 
                      (make-node :kernel/var {
                        :ref (ref-node :exchange_kernel)
                      })
                    })
                  })
                ])
              })
            })
          })
          (make-node :view/sequence [
            (make-node :view/expr/symbol { :str :to })
            (make-node :view/quad)
            (make-node :kernel/unquote {
              :body 
              (make-node :kernel/var {
                :ref (ref-node :exchange_value)
              })
            })
          ])
        ])
      })
    })

    ; doc
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :core/doc)
      
      :supers 
      (make-node :grammar/types [])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :doc_string {
          :name
          (make-node :grammar/name :core/doc/string)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/string)
          ])
        })
      ])
      
      :display
      (make-node :kernel/quote {
        :body
        (make-node :view/expr/doc {
;        (make-node :view/chars {  ; Note: this is the right reduction, but doesn't render properly via the meta-expr reduction
          :str
          (make-node :kernel/unquote {
            :body
            ; (make-node :kernel/app {
            ;   :expr
            ;   (make-node :kernel/extern { :name "meta.core/node-value" })
            ;   
            ;   :args
            ;   (make-node :kernel/args [
                (make-node :kernel/var {
                  :ref (ref-node :doc_string)
                })
            ;   ])
            ; })
          })
          
;          :font :times
          
;          :view/drawable/color
;          (make-node :view/gray { :brightness 0.5 })
        })
      })
    })

    ; comment
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :core/comment)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :comment_expr {
          :name
          (make-node :grammar/name :core/comment/expr)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :kernel/quote {
        :body
        (make-node :view/border {
          :weight 1
          :margin 3
          
          :view/drawable/colors 
          (make-node :lorax/seq [ 
            (make-node :view/rgb { :red 0.7 :green 0.7 :blue 0.7 })
          ])
   
          :fill
          (make-node :view/rgb { :red 0.9 :green 0.9 :blue 0.9 })
          
          :item
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :comment_expr)
            })
          })
        })
      })
  
      :expand
      (make-node :kernel/quote {
        :body
        (make-node :kernel/nil)
      })
    })
  
    ; fail
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :core/fail)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [])
      
      :display
      (make-node :kernel/quote {
        :body
        (make-node :view/expr/keyword { :str "fail" })
      })
  
      :expand
      (make-node :kernel/quote {
        :body
        (make-node :kernel/app {
          :expr
          (make-node :kernel/extern { :name "throw" })
          
          :args
          (make-node :kernel/args [
            (make-node :kernel/app {
              :expr
              (make-node :kernel/extern { :name "Exception." })
          
              :args
              (make-node :kernel/args [
                (make-node :kernel/string { :value "failed" })
              ])
            })
          ])
        })
      })
    })
  
    ; not
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :core/not)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :not_expr {
          :name
          (make-node :grammar/name :core/not/expr)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :kernel/quote {
        :body
        (make-node :view/expr/juxt [
          (make-node :view/expr/symbol { :str :neg })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :not_expr)
            })
          })
        ])
      })
  
      :expand
      (make-node :kernel/quote {
        :body
        (make-node :kernel/if {
          :test
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :not_expr)
            })
          })
      
          :then
          (make-node :kernel/false)
      
          :else
          (make-node :kernel/true)
        })
      })
    })
  
    ; unaryminus
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :core/unaryminus)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :unaryminus_expr {
          :name
          (make-node :grammar/name :core/unaryminus/expr)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :kernel/quote {
        :body
        (make-node :view/expr/juxt [
          (make-node :view/expr/symbol { :str "-" })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :unaryminus_expr)
            })
          })
        ])
      })
  
      :expand
      (make-node :kernel/quote {
        :body
        (make-node :kernel/app {
          :expr
          (make-node :kernel/extern { :name "-" })
          
          :args
          (make-node :kernel/args [
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :unaryminus_expr)
              })
            })
          ])
        })
      })
    })

    ; sqrt
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :core/sqrt)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :sqrt_expr {
          :name
          (make-node :grammar/name :core/sqrt/expr)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :kernel/quote {
        :body
        (make-node :view/radical {
          :radicand
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :sqrt_expr)
            })
          })
        })
      })
  
      :expand
      (make-node :kernel/quote {
        :body
        (make-node :kernel/app {
          :expr
          (make-node :kernel/extern { :name "Math/sqrt" })
          
          :args
          (make-node :kernel/args [
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :sqrt_expr)
              })
            })
          ])
        })
      })
    })

    ; plus
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :core/plus)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :plus_left {
          :name
          (make-node :grammar/name :core/plus/left)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
        })
        (make-node :grammar/attr :plus_right {
          :name
          (make-node :grammar/name :core/plus/right)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :kernel/quote {
        :body
        (make-node :view/expr/relation [
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :plus_left)
            })
          })
          (make-node :view/expr/symbol { :str "+" })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :plus_right)
            })
          })
        ])
      })
  
      :expand
      (make-node :kernel/quote {
        :body
        (make-node :kernel/app {
          :expr
          (make-node :kernel/extern { :name "+" })
          
          :args
          (make-node :kernel/args [
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :plus_left)
              })
            })
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :plus_right)
              })
            })
          ])
        })
      })
    })

    ; minus
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :core/minus)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :minus_left {
          :name
          (make-node :grammar/name :core/minus/left)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
        })
        (make-node :grammar/attr :minus_right {
          :name
          (make-node :grammar/name :core/minus/right)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :kernel/quote {
        :body
        (make-node :view/expr/relation [
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :minus_left)
            })
          })
          (make-node :view/expr/symbol { :str "-" })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :minus_right)
            })
          })
        ])
      })
  
      :expand
      (make-node :kernel/quote {
        :body
        (make-node :kernel/app {
          :expr
          (make-node :kernel/extern { :name "-" })
          
          :args
          (make-node :kernel/args [
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :minus_left)
              })
            })
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :minus_right)
              })
            })
          ])
        })
      })
    })

    ; times
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :core/times)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :times_left {
          :name
          (make-node :grammar/name :core/times/left)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
        })
        (make-node :grammar/attr :times_right {
          :name
          (make-node :grammar/name :core/times/right)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :kernel/quote {
        :body
        (make-node :view/expr/binary [
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :times_left)
            })
          })
          (make-node :view/expr/symbol { :str :cdot }) ; :times
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :times_right)
            })
          })
        ])
      })
  
      :expand
      (make-node :kernel/quote {
        :body
        (make-node :kernel/app {
          :expr
          (make-node :kernel/extern { :name "*" })
          
          :args
          (make-node :kernel/args [
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :times_left)
              })
            })
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :times_right)
              })
            })
          ])
        })
      })
    })

    ; greater
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :core/greater)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :greater_left {
          :name
          (make-node :grammar/name :core/greater/left)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
        })
        (make-node :grammar/attr :greater_right {
          :name
          (make-node :grammar/name :core/greater/right)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :kernel/quote {
        :body
        (make-node :view/expr/relation [
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :greater_left)
            })
          })
          (make-node :view/expr/symbol { :str ">" })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :greater_right)
            })
          })
        ])
      })
  
      :expand
      (make-node :kernel/quote {
        :body
        (make-node :kernel/app {
          :expr
          (make-node :kernel/extern { :name ">" })
          
          :args
          (make-node :kernel/args [
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :greater_left)
              })
            })
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :greater_right)
              })
            })
          ])
        })
      })
    })

    ; equal
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :core/equal)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :equal_left {
          :name
          (make-node :grammar/name :core/equal/left)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
        })
        (make-node :grammar/attr :equal_right {
          :name
          (make-node :grammar/name :core/equal/right)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :kernel/quote {
        :body
        (make-node :view/expr/relation [
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :equal_left)
            })
          })
          (make-node :view/expr/symbol { :str "=" })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :equal_right)
            })
          })
        ])
      })
  
      :expand
      (make-node :kernel/quote {
        :body
        (make-node :kernel/app {
          :expr
          (make-node :kernel/extern { :name "=" })
          
          :args
          (make-node :kernel/args [
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :equal_left)
              })
            })
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :equal_right)
              })
            })
          ])
        })
      })
    })

    ; :fraction
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :core/fraction)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :fraction_num {
          :name
          (make-node :grammar/name :core/fraction/num)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
        })
        (make-node :grammar/attr :fraction_denom {
          :name
          (make-node :grammar/name :core/fraction/denom)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :kernel/quote {
        :body
        (make-node :view/over {
          :top
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :fraction_num)
            })
          })
          
          :weight 1
          
          :bottom
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :fraction_denom)
            })
          })
        })
      })
  
      :expand
      (make-node :kernel/quote {
        :body
        (make-node :kernel/app {
          :expr
          (make-node :kernel/extern { :name "/" })
          
          :args
          (make-node :kernel/args [
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :fraction_num)
              })
            })
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :fraction_denom)
              })
            })
          ])
        })
      })
    })

    ; "square" expr: using simple multiplication, so it works on integers, 
    ; ratios, etc., unlike Java's pow() fn, which always gives you a double
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :core/square)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :square_expr {
          :name
          (make-node :grammar/name :core/square/expr)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
        })
      ])
    
      :display
      (make-node :kernel/quote {
        :body
        (make-node :view/scripted {
          :nucleus
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :square_expr)
            })
          })
          
          :super
          (make-node :view/expr/int { :str "2" })
        })
      })
      
      :expand
      (make-node :kernel/quote {
        :body
        (make-node :kernel/let {
          :bind
          (make-node :kernel/bind :n_square {})
          
          :expr
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :square_expr)
            })
          })
          
          :body
          (make-node :core/times {
            :left
            (make-node :kernel/var {
              :ref (ref-node :n_square)
            })
            
            :right
            (make-node :kernel/var {
              :ref (ref-node :n_square)
            })
          })
        })
      })
    })

  ; and
  (make-node :grammar/mapNode {
    :type
    (make-node :grammar/type :core/and)
    
    :supers 
    (make-node :grammar/types [ 
      (make-node :grammar/type :kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :and_left {
        :name
        (make-node :grammar/name :core/and/left)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node {
              :type :kernel/expr
            })
        ])
      })
      (make-node :grammar/attr :and_right {
        :name
        (make-node :grammar/name :core/and/right)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node {
              :type :kernel/expr
            })
        ])
      })
    ])
    
    :display
    (make-node :kernel/quote {
      :body
      (make-node :view/expr/relation [
        (make-node :kernel/unquote {
          :body
          (make-node :kernel/var {
            :ref (ref-node :and_left)
          })
        })
        (make-node :view/expr/keyword { :str "and" })
        (make-node :kernel/unquote {
          :body
          (make-node :kernel/var {
            :ref (ref-node :and_right)
          })
        })
      ])
    })

    :expand
    (make-node :kernel/quote {
      :body
      (make-node :kernel/let {
        :bind 
        (make-node :kernel/bind :l_and {})
        
        :expr
        (make-node :kernel/unquote {
          :body
          (make-node :kernel/var {
            :ref (ref-node :and_left)
          })
        })
        
        :body
        (make-node :kernel/if {
          :test
          (make-node :core/not {
            :expr
            (make-node :kernel/var {
              :ref (ref-node :l_and)
            })
          })
          
          :then
          (make-node :kernel/var {
            :ref (ref-node :l_and)
          })
          
          :else
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :and_right)
            })
          })
        })
      })
    })
  })

    ; ; binary AND
    ; (node :grammar/rule
    ;   :type
    ;   :core/and
    ;   
    ;   :supers [ :kernel/expr ]
    ;   
    ;   :display  ; TODO: quote it?
    ;   (node :view/expr/relation
    ;     :boxes [
    ;       (node :grammar/attr :lorax/id :left
    ;         :name 
    ;         :core/and/left
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;       (node :view/expr/keyword :str "and")
    ;       (node :grammar/attr :lorax/id :right
    ;         :name 
    ;         :core/and/right
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;     ])
    ;     
    ;     :expand
    ;     (node :kernel/quote
    ;       :body
    ;       (node :kernel/let
    ;         :bind 
    ;         (node :kernel/bind :lorax/id :l)
    ;         
    ;         :expr
    ;         (node :kernel/unquote
    ;           :body
    ;           (node :kernel/var 
    ;             :ref (ref-node :left)))
    ;         
    ;         :body
    ;         (node :kernel/if
    ;           :test
    ;           (node :core/not 
    ;             :expr
    ;             (node :kernel/var 
    ;               :ref (ref-node :l)))
    ;           
    ;           :then
    ;           (node :kernel/var 
    ;             :ref (ref-node :l))
    ;           
    ;           :else
    ;           (node :kernel/unquote
    ;             :body
    ;             (node :kernel/var 
    ;               :ref (ref-node :right)))))))
    ;     
    ; ; TODO: OR
    ;     
    ; ; binary +
    ; (node :grammar/rule
    ;   :type
    ;   :core/plus
    ;   
    ;   :supers [ :kernel/expr ]
    ;   
    ;   :display  ; TODO: quote it?
    ;   (node :view/expr/binary
    ;     :boxes [
    ;       (node :grammar/attr :lorax/id :left2
    ;         :name 
    ;         :core/plus/left
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;       (node :view/expr/symbol :str "+")
    ;       (node :grammar/attr :lorax/id :right2
    ;         :name 
    ;         :core/plus/right
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;     ])
    ;     
    ;     :expand
    ;     (node :kernel/quote
    ;       :body
    ;       (node :kernel/app
    ;         :expr 
    ;         (node :kernel/extern :name "+")
    ;         
    ;         :args [
    ;           (node :kernel/unquote
    ;             :body
    ;             (node :kernel/var 
    ;               :ref (ref-node :left2)))
    ;           
    ;           (node :kernel/unquote
    ;             :body
    ;             (node :kernel/var 
    ;               :ref (ref-node :right2)))
    ;         ])))
    ; 
    ; ; binary -
    ; (node :grammar/rule
    ;   :type
    ;   :core/minus
    ;   
    ;   :supers [ :kernel/expr ]
    ;   
    ;   :display  ; TODO: quote it?
    ;   (node :view/expr/binary
    ;     :boxes [
    ;       (node :grammar/attr :lorax/id :left3
    ;         :name 
    ;         :core/minus/left
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;       (node :view/expr/symbol :str "-")
    ;       (node :grammar/attr :lorax/id :right3
    ;         :name 
    ;         :core/minus/right
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;     ])
    ;     
    ;     :expand
    ;     (node :kernel/quote
    ;       :body
    ;       (node :kernel/app
    ;         :expr 
    ;         (node :kernel/extern :name "-")
    ;         
    ;         :args [
    ;           (node :kernel/unquote
    ;             :body
    ;             (node :kernel/var 
    ;               :ref (ref-node :left3)))
    ;           
    ;           (node :kernel/unquote
    ;             :body
    ;             (node :kernel/var 
    ;               :ref (ref-node :right3)))
    ;         ])))
    ; 
    ; ; binary *
    ; (node :grammar/rule
    ;   :type
    ;   :core/times
    ;   
    ;   :supers [ :kernel/expr ]
    ;   
    ;   :display  ; TODO: quote it?
    ;   (node :view/expr/binary
    ;     :boxes [
    ;       (node :grammar/attr :lorax/id :left4
    ;         :name 
    ;         :core/times/left
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;       (node :view/expr/symbol :str :times)
    ;       (node :grammar/attr :lorax/id :right4
    ;         :name 
    ;         :core/times/right
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;     ])
    ;     
    ;     :expand
    ;     (node :kernel/quote
    ;       :body
    ;       (node :kernel/app
    ;         :expr 
    ;         (node :kernel/extern :name "*")
    ;         
    ;         :args [
    ;           (node :kernel/unquote
    ;             :body
    ;             (node :kernel/var 
    ;               :ref (ref-node :left4)))
    ;           
    ;           (node :kernel/unquote
    ;             :body
    ;             (node :kernel/var 
    ;               :ref (ref-node :right4)))
    ;         ])))
    ; 
    ; ; binary >
    ; (node :grammar/rule
    ;   :type
    ;   :core/greater
    ;   
    ;   :supers [ :kernel/expr ]
    ;   
    ;   :display  ; TODO: quote it?
    ;   (node :view/expr/relation
    ;     :boxes [
    ;       (node :grammar/attr :lorax/id :left5
    ;         :name 
    ;         :core/greater/left
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;       (node :view/expr/symbol :str ">")
    ;       (node :grammar/attr :lorax/id :right5
    ;         :name 
    ;         :core/greater/right
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;     ])
    ;     
    ;     :expand
    ;     (node :kernel/quote
    ;       :body
    ;       (node :kernel/app
    ;         :expr 
    ;         (node :kernel/extern :name ">")
    ;         
    ;         :args [
    ;           (node :kernel/unquote
    ;             :body
    ;             (node :kernel/var 
    ;               :ref (ref-node :left5)))
    ;           
    ;           (node :kernel/unquote
    ;             :body
    ;             (node :kernel/var 
    ;               :ref (ref-node :right5)))
    ;         ])))
    ; 
    ; ; TODO: >=, <, <=, =, !=
    ; 
    ; 
    ; 
    ; ;
    ; ; Sequences
    ; ;
    ; 
    ; ; Sequence (list) constructor:
    ; (node :grammar/rule
    ;   :type
    ;   :core/sequence
    ;   
    ;   :supers [ :kernel/expr ]
    ;   
    ;   :display
    ;   (node :view/sequence
    ;     :items
    ;     (node :grammar/sequence :lorax/id :items1
    ;       :name 
    ;       :core/sequence/items
    ;       
    ;       :options [
    ;         (node :structure/node
    ;           :type :kernel/expr)
    ;       ]
    ;       
    ;       :min 0
    ;       
    ;       :separator
    ;       (node :view/sequence
    ;         :items [
    ;           (node :view/expr/keyword :str ",")
    ;           (node :view/thickspace)
    ;         ])))
    ;   
    ;   :expand
    ;   (node :kernel/quote
    ;     :body
    ;     (node :kernel/app
    ;       :expr
    ;       (node :kernel/extern
    ;         :name "list")
    ;         
    ;       :args
    ;       (node :kernel/unquote
    ;         :body
    ;         (node :kernel/var
    ;           :ref (ref-node :items1))))))
    ; 
    ; ; cons(), as "."
    ; (node :grammar/rule
    ;   :type 
    ;   :core/cons
    ;   
    ;   :supers [ :kernel/expr ]
    ;   
    ;   :display
    ;   (node :view/expr/relation
    ;     :boxes [
    ;       (node :grammar/attr :lorax/id :first0
    ;         :name 
    ;         :core/cons/first
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;       (node :view/expr/symbol :str ".")
    ;       (node :grammar/attr
    ;         :name 
    ;         :core/cons/rest :lorax/id :rest0
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;     ])
    ;   
    ;   :expand
    ;   (node :kernel/quote
    ;     :body
    ;     (node :kernel/app
    ;       :expr
    ;       (node :kernel/extern
    ;         :name "cons")
    ;       
    ;       :args [
    ;         (node :kernel/unquote
    ;           :body
    ;           (node :kernel/var
    ;             :ref (ref-node :first0)))
    ;         (node :kernel/unquote
    ;           :body
    ;           (node :kernel/var
    ;             :ref (ref-node :rest0)))
    ;       ])))
    ; 
    ; ; first(coll)
    ; (node :grammar/rule
    ;   :type
    ;   :core/first
    ;   
    ;   :supers [ :kernel/expr ]
    ;   
    ;   :display
    ;   (node :view/expr/juxt
    ;     :boxes [
    ;       (node :view/expr/keyword :str "first")
    ;       (node :view/parens
    ;         :left "["
    ;         :right "]"
    ;         
    ;         :content
    ;         (node :grammar/attr :lorax/id :coll1
    ;           :name
    ;           :core/first/coll
    ;           
    ;           :options [
    ;             (node :structure/node
    ;               :type :kernel/expr)
    ;           ]
    ;           
    ;           :optional false))
    ;     ])
    ;   
    ;   :expand
    ;   (node :kernel/quote
    ;     :body
    ;     (node :kernel/app
    ;       :expr
    ;       (node :kernel/extern
    ;         :name "first")
    ;       
    ;       :args [
    ;         (node :kernel/unquote
    ;           :body
    ;           (node :kernel/var
    ;             :ref (ref-node :coll1)))
    ;       ])))
    ; 
    ; ; rest(coll)
    ; (node :grammar/rule
    ;   :type
    ;   :core/rest
    ;   
    ;   :supers [ :kernel/expr ]
    ;   
    ;   :display
    ;   (node :view/expr/juxt
    ;     :boxes [
    ;       (node :view/expr/keyword :str "rest")
    ;       (node :view/parens
    ;         :left "["
    ;         :right "]"
    ;         
    ;         :content
    ;         (node :grammar/attr :lorax/id :coll2
    ;           :name
    ;           :core/rest/coll
    ;           
    ;           :options [
    ;             (node :structure/node
    ;               :type :kernel/expr)
    ;           ]
    ;           
    ;           :optional false))
    ;     ])
    ;   
    ;   :expand
    ;   (node :kernel/quote
    ;     :body
    ;     (node :kernel/app
    ;       :expr
    ;       (node :kernel/extern
    ;         :name "rest")
    ;       
    ;       :args [
    ;         (node :kernel/unquote
    ;           :body
    ;           (node :kernel/var
    ;             :ref (ref-node :coll2)))
    ;       ])))
    ; 
    ; ; subscript
    ; (node :grammar/rule
    ;   :type
    ;   :core/nth
    ;   
    ;   :supers [ :kernel/expr ]
    ;   
    ;   :display
    ;   (node :view/expr/juxt
    ;     :boxes [
    ;       (node :grammar/attr :lorax/id :coll0
    ;         :name
    ;         :core/nth/coll
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;       (node :view/parens
    ;         :left "["
    ;         :right "]"
    ;         
    ;         :content
    ;         (node :grammar/attr :lorax/id :index0
    ;           :name
    ;           :core/nth/index
    ;         
    ;           :options [
    ;             (node :structure/node
    ;               :type :kernel/expr)
    ;           ]
    ;         
    ;           :optional false))
    ;     ])
    ;   
    ;   :expand
    ;   (node :kernel/quote
    ;     :body
    ;     (node :kernel/app
    ;       :expr
    ;       (node :kernel/extern
    ;         :name "nth")
    ;       
    ;       :args [
    ;         (node :kernel/unquote
    ;           :body
    ;           (node :kernel/var
    ;             :ref (ref-node :coll0)))
    ;         (node :kernel/unquote
    ;           :body
    ;           (node :kernel/var
    ;             :ref (ref-node :index0)))
    ;       ])))
    ; 
    ; 
    ; (node :grammar/rule
    ;   :type
    ;   :core/set
    ;   
    ;   :supers [ :kernel/expr ]
    ;   
    ;   :display
    ;   (node :view/parens
    ;     :left "{"
    ;     :right "}"
    ;     
    ;     :content
    ;     (node :grammar/attr :lorax/id :coll5
    ;       :name 
    ;       :core/set/coll
    ;       
    ;       :options [
    ;           (node :structure/node
    ;             :type :kernel/expr)          
    ;       ]
    ;       
    ;       :optional false))
    ;     
    ;     :expand
    ;     (node :kernel/quote
    ;       :body
    ;       (node :kernel/app
    ;         :expr
    ;         (node :kernel/extern
    ;           :name "set")
    ;           
    ;         :args [
    ;           (node :kernel/unquote
    ;             :body
    ;             (node :kernel/var
    ;               :ref (ref-node :coll5)))
    ;         ])))
    ; 
    ; ; in (contains?):
    ; (node :grammar/rule
    ;   :type
    ;   :core/in
    ;   
    ;   :supers [ :kernel/expr ]
    ;   
    ;   :display  ; TODO: quote it?
    ;   (node :view/expr/relation
    ;     :boxes [
    ;       (node :grammar/attr :lorax/id :elem6
    ;         :name 
    ;         :core/in/item
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;       (node :view/expr/symbol :str :in)
    ;       (node :grammar/attr :lorax/id :coll6
    ;         :name 
    ;         :core/in/set
    ;         
    ;         :options [
    ;           (node :structure/node
    ;             :type :kernel/expr)
    ;         ]
    ;         
    ;         :optional false)
    ;     ])
    ;     
    ;     :expand
    ;     (node :kernel/quote
    ;       :body
    ;       (node :kernel/app
    ;         :expr 
    ;         (node :kernel/extern :name "contains?")
    ;         
    ;         :args [
    ;           (node :kernel/unquote
    ;             :body
    ;             (node :kernel/var 
    ;               :ref (ref-node :elem6)))
    ;           
    ;           (node :kernel/unquote
    ;             :body
    ;             (node :kernel/var 
    ;               :ref (ref-node :coll6)))
    ;         ])))
    ; 
    ; ; postfix factorial (not really a "core" thing, but interesting?)
    ; (node :grammar/rule
    ;   :type
    ;   :core/factorial
    ;   
    ;   :supers [ :kernel/expr ]
    ;   
    ;   :display
    ;   (node :view/expr/juxt
    ;     :boxes [
    ;       (node :grammar/attr :lorax/id :e3
    ;         :name
    ;         :core/factorial/expr
    ;       
    ;         :options [
    ;           (node :structure/node
    ;             :type :kernel/expr)
    ;         ]
    ;       
    ;         :optional false)
    ;       (node :view/expr/symbol :str "!")
    ;     ])
    ;     
    ;   :expand
    ;   (node :kernel/quote
    ;     :body
    ;     (node :kernel/let
    ;       :bind 
    ;       (node :kernel/bind :lorax/id :fact)
    ;       
    ;       :expr
    ;       (node :kernel/lambda :lorax/id :factr
    ;         :params [
    ;           (node :kernel/bind :lorax/id :n1)
    ;         ]
    ;         
    ;         :body
    ;         (node :kernel/if
    ;           :test
    ;           (node :core/greater
    ;             :left
    ;             (node :kernel/var
    ;               :ref (ref-node :n1))
    ;             
    ;             :right
    ;             (node :kernel/int :value 1))
    ;             
    ;           :then
    ;           (node :core/times
    ;             :left
    ;             (node :kernel/var
    ;               :ref (ref-node :n1))
    ;               
    ;             :right
    ;             (node :kernel/app
    ;               :expr
    ;               (node :kernel/var 
    ;                 :ref (ref-node :factr))
    ;                 
    ;               :args [
    ;                 (node :core/minus
    ;                   :left 
    ;                   (node :kernel/var
    ;                     :ref (ref-node :n1))
    ;                   
    ;                   :right
    ;                   (node :kernel/int :value 1))
    ;               ]))
    ;             
    ;             :else
    ;             (node :kernel/int :value 1)))
    ;       
    ;       :body
    ;       (node :kernel/app
    ;         :expr
    ;         (node :kernel/var
    ;           :ref (ref-node :fact))
    ;       
    ;         :args [
    ;           (node :kernel/unquote
    ;             :body
    ;             (node :kernel/var
    ;               :ref (ref-node :e3)))
    ;         ]))))
    ;

    ; where
    (make-node :grammar/mapNode {
      :type 
      (make-node :grammar/type :core/where)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :where_body {
          :name
          (make-node :grammar/name :core/where/body)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
        })
        (make-node :grammar/attr :where_vars {
          :name
          (make-node :grammar/name :core/where/vars)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :core/whereVars
              })
          ])
        })
      ])
      
      :display
      (make-node :kernel/quote {
        :body
        (make-node :view/section [
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :where_body)
            })
          })
          (make-node :view/sequence [
            (make-node :view/quad)
            (make-node :view/expr/keyword { :str "where" })
          ])
          (make-node :view/sequence [
            (make-node :view/quad)
            (make-node :view/quad)
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :where_vars)
              })
            })
          ])
        ])
      })
      
      :expand
      (make-node :kernel/if {
        :test
        (make-node :core/equal {
          :left
          (make-node :core/nodeCount {
            :node
            (make-node :kernel/var {
              :ref (ref-node :where_vars)
            })
          })

          :right
          (make-node :kernel/int { :value 0 })
        })
        
        :then
        (make-node :kernel/var {
          :ref (ref-node :where_body)
        })
        
        :else
        (make-node :core/makeNode {
          :type
          (make-node :kernel/name { :value :core/where })
          
          :content
          (make-node :core/nodeAttrs [
            (make-node :core/nodeAttr {
              :name
              (make-node :kernel/name { :value :body })
              
              :value
              (make-node :kernel/quote {
                :body
                (make-node :kernel/let {
                  :bind
                  (make-node :kernel/unquote {
                    :body
                    (make-node :core/attr {
                      :node
                      (make-node :core/nodeFirst {
                        :node
                        (make-node :kernel/var {
                          :ref (ref-node :where_vars)
                        })
                      })
                    
                      :name
                      (make-node :kernel/name { :value :bind })
                    })
                  })
                  
                  :expr
                  (make-node :kernel/unquote {
                    :body
                    (make-node :core/attr {
                      :node
                      (make-node :core/nodeFirst {
                        :node
                        (make-node :kernel/var {
                          :ref (ref-node :where_vars)
                        })
                      })
                    
                      :name
                      (make-node :kernel/name { :value :expr })
                    })
                  })
                  
                  :body
                  (make-node :kernel/unquote {
                    :body
                    (make-node :kernel/var {
                      :ref (ref-node :where_body)
                    })
                  })                  
                })
              })
            })
            (make-node :core/nodeAttr {
              :name
              (make-node :kernel/name { :value :vars })
              
              :value
              (make-node :core/nodeRest {
                :node
                ; (make-node :kernel/nil) ; HACK
                (make-node :kernel/var {
                  :ref (ref-node :where_vars)
                })
              })
            })
          ])
        })
        
      })
    })
    
    ; whereVars
    (make-node :grammar/seqNode {
      :type 
      (make-node :grammar/type :core/whereVars)
      
      :supers 
      (make-node :grammar/types [])

      :options 
      (make-node :grammar/options [
        (make-node :grammar/node {
          :type :kernel/whereVar
        })
      ])
      
      :min
      (make-node :grammar/count 1)
          
      :display
      (make-node :grammar/seq {
        :type 
        (make-node :grammar/type :view/section)
        
        ; :separator
        ; (make-node :view/expr/keyword { :str " " })
      })
    })
    
    ; whereVar
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :core/whereVar)
      
      :supers 
      (make-node :grammar/types [])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :whereVar_bind {
          :name
          (make-node :grammar/name :core/whereVar/bind)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/bind
              })
          ])
        })
        (make-node :grammar/attr :whereVar_expr {
          :name
          (make-node :grammar/name :core/whereVar/expr)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
        })
      ])
      
      :display
      (make-node :kernel/quote {
        :body
        ; Note: _not_ using :view/expr/flow because don't need parens around main expr in this case!
        (make-node :view/sequence [
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :whereVar_bind)
            })
          })
          (make-node :view/thickspace)
          (make-node :view/expr/symbol { :str "=" })
          (make-node :view/thickspace)
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :whereVar_expr)
            })
          })
        ])
      })
    })  
    
    ; let2
    (make-node :grammar/mapNode {
      :doc
      (make-node :grammar/doc { :str "Just a syntactic variation." })
      
      :type
      (make-node :grammar/type :core/let2)
      
      :supers
      (make-node :grammar/types [ 
        (make-node :grammar/type :kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :let2_bind {
          :name
          (make-node :grammar/name :core/let2/bind)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/bind
              })
          ])
          
          :optional false
        })
        (make-node :grammar/attr :let2_expr {
          :name
          (make-node :grammar/name :core/let2/expr)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
          
          :optional false
        })
        (make-node :grammar/attr :let2_body {
          :name
          (make-node :grammar/name :core/let2/body)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :kernel/expr
              })
          ])
          
          :optional false
        })
      ])

      :display
      (make-node :kernel/quote {
        :body
        (make-node :view/section [
          (make-node :view/expr/flow [
            (make-node :view/expr/keyword { :str "let" })
            (make-node :kernel/unquote {
              :body 
              (make-node :kernel/var {
                :ref (ref-node :let2_bind)
              })
            })
            (make-node :view/expr/symbol { :str "=" })
            (make-node :kernel/unquote {
              :body 
              (make-node :kernel/var {
                :ref (ref-node :let2_expr)
              })
            })
          ])
          (make-node :view/sequence [
            (make-node :view/quad)
            ; HACK: don't use :flow, which would provoke parens
            (make-node :view/expr/keyword { :str "in" })
            (make-node :view/thickspace)
            (make-node :kernel/unquote {
              :body 
              (make-node :kernel/var {
                :ref (ref-node :let2_body)
              })
            })
          ])
        ])
      })
      
      :expand 
      (make-node :kernel/quote {
        :body
        (make-node :kernel/let {
          :bind
          (make-node :kernel/unquote {
            :body 
            (make-node :kernel/var {
              :ref (ref-node :let2_bind)
            })
          })
          
          :expr
          (make-node :kernel/unquote {
            :body 
            (make-node :kernel/var {
              :ref (ref-node :let2_expr)
            })
          })
          
          :body
          (make-node :kernel/unquote {
            :body 
            (make-node :kernel/var {
              :ref (ref-node :let2_body)
            })
          })
        })
      })
    })
])
