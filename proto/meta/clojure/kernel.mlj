; Grammar/presentation for the 'kernel' language, which is directly translatable to 
; ordinary Clojure forms (and therefore no expansions are provided).
;
; This version uses the higher-level "grammar" language, which specifies structure as 
; well as a presentation reduction, and which can be reduced/compiled down into both a
; regular structure program and a presentation reduction.

(use 'meta.core)  ; ignored by load-nodes, but should make this file legal Clojure

(make-node :grammar/language [
    (make-node :grammar/mapNode {
        :type
        (make-node :grammar/type :clojure/kernel/nil)
      
        :supers 
        (make-node :grammar/types [ 
            (make-node :grammar/type :clojure/kernel/expr)
          ])
      
        :attrs
        (make-node :grammar/attrs [])
        
        :display
        (make-node :clojure/kernel/quote {
            :body
            (node :view/expr/keyword
              :str "nil")
          })
      })
            
    (make-node :grammar/mapNode {
        :type
        (make-node :grammar/type :clojure/kernel/true)
    
        :supers
        (make-node :grammar/types [ 
            (make-node :grammar/type :clojure/kernel/expr)
          ])
        
        :attrs
        (make-node :grammar/attrs [])
        
        :display
        (make-node :clojure/kernel/quote {
            :body
            (node :view/expr/keyword
              :str "true")
          })
      })
        
    (make-node :grammar/mapNode {
        :type
        (make-node :grammar/type :clojure/kernel/false)
      
        :supers
        (make-node :grammar/types [ 
            (make-node :grammar/type :clojure/kernel/expr)
          ])
      
        :attrs
        (make-node :grammar/attrs [])
        
        :display
        (make-node :clojure/kernel/quote {
            :body
            (node :view/expr/keyword
              :str "false")
          })
      })
      
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/kernel/int)
    
      :supers
      (make-node :grammar/types [
          (make-node :grammar/type :clojure/kernel/expr)
        ])
    
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :int_value {
          :name
          (make-node :grammar/name :clojure/kernel/int/value)

          :options
          (make-node :grammar/options [
            (node :grammar/int)
          ])
      
          :optional
          false
        })
      ])
      
      ; Now that quoting is fixed, it's not so bad:
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/expr/int {
          :str
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/app {
              :expr
              (make-node :clojure/kernel/extern { :name "str" })
                      
              :args 
              (make-node :clojure/kernel/args [
                (make-node :clojure/kernel/app {
                  :expr
                  (make-node :clojure/kernel/extern { :name "meta.core/node-value" })
                      
                  :args 
                  (make-node :clojure/kernel/args [
                    (make-node :clojure/kernel/var {
                      :ref (ref-node :int_value) 
                    })
                  ])
                })
              ])
            })
          })
        })
      })
    })
        
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/kernel/string)
    
      :supers
      (make-node :grammar/types [ 
        (make-node :grammar/type :clojure/kernel/expr)
      ])
    
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :string_value {
          :name
          (make-node :grammar/name :clojure/kernel/string/value)

          :options
          (make-node :grammar/options [
            (node :grammar/string)
          ])
      
          :optional
          false
        })
      ])
      
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/expr/string {
          :str
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/app {
              :expr
              (make-node :clojure/kernel/extern { :name "meta.core/node-value" })
                      
              :args 
              (make-node :clojure/kernel/args [
                (make-node :clojure/kernel/var {
                  :ref (ref-node :string_value) 
                })
              ])
            })
          })
        })
      })
    })
      
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/kernel/name)
    
      :supers
      (make-node :grammar/types [ 
        (make-node :grammar/type :clojure/kernel/expr)
      ])
    
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :name_value {
          :name
          (make-node :grammar/name :clojure/kernel/name/value)

          :options
          (make-node :grammar/options [
            (node :grammar/string)  ; TODO: what represents a name?
          ])
      
          :optional
          false
        })
      ])
      
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/expr/keyword {
          ; TODO: color? raw keyword isn't right; a color attribute here
          ; is not propagated through the reduction to :view, though
          ; (make-node :clojure/kernel/name { :value :view/drawable/color })
          ; (make-node :clojure/kernel/quote {
          ;   :body
          ;   (make-node :view/rgb { :red 0.2 :green 0.2 :blue 0.5 })
          ; })
          
          :str
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/app {
              :expr
              (make-node :clojure/kernel/extern { :name "subs" })
          
              :args
              (make-node :clojure/kernel/args [
                (make-node :clojure/kernel/app {
                  :expr
                  (make-node :clojure/kernel/extern { :name "str" })
          
                  :args
                  (make-node :clojure/kernel/args [
                    (make-node :clojure/kernel/app {
                      :expr
                      (make-node :clojure/kernel/extern { :name "meta.core/node-value" })
          
                      :args 
                      (make-node :clojure/kernel/args [
                        (make-node :clojure/kernel/var {
                          :ref (ref-node :name_value) 
                        })
                      ])
                    })
                  ])
                })
                (make-node :clojure/kernel/int { :value 1 })
              ])
            })
          })
        })
      })
    })
    
    (make-node :grammar/mapNode {
        :type 
        (make-node :grammar/type :clojure/kernel/bind)
       
        :supers
        (make-node :grammar/types [])
       
        :attrs
        (make-node :grammar/attrs [])
    
        ; Note: this reduction never actually occurs, because bindings, like 
        ; all nodes that introduce names, are reduced by the special name 
        ; reduction prior to the reduction driven by the grammar.
        :display
        (make-node :clojure/kernel/quote {
          :body
          (make-node :view/expr/var { 
            :str "?" 
          })
        })
      })
    
    (make-node :grammar/mapNode {
        :type
        (make-node :grammar/type :clojure/kernel/lambda)
      
        :supers 
        (make-node :grammar/types [ 
            (make-node :grammar/type :clojure/kernel/expr)
          ])
        
        :attrs
        (make-node :grammar/attrs [
            (make-node :grammar/attr :lambda_params {
                :name
                (make-node :grammar/name :clojure/kernel/lambda/params)
              
                :options
                (make-node :grammar/options [
                    (make-node :grammar/node {
                        :type :clojure/kernel/params
                      })
                  ])
    
                :optional false
              })
            (make-node :grammar/attr :lambda_body {
                :name
                (make-node :grammar/name :clojure/kernel/lambda/body)
              
                :options
                (make-node :grammar/options [
                    (make-node :grammar/node {
                        :type :clojure/kernel/expr
                      })
                  ])
    
                :optional false
              })
          ])
      
        :display
        (make-node :clojure/kernel/quote {
          :body
          (make-node :view/expr/flow [
            (node :view/expr/keyword :str "fn")
  
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :lambda_params)
              })
            })
          
            (node :view/expr/symbol :str :to)
        
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :lambda_body)
              })
            })
          ])              
        })
      })
      
      (make-node :grammar/seqNode {
        :type
        (make-node :grammar/type :clojure/kernel/params)
      
        :supers 
        (make-node :grammar/types [])
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node {
              :type
              :clojure/kernel/bind
            })
        ])
          
        :min
        0
        
        :display
        (make-node :grammar/seq {
          ; :ref
          ; (ref-node ???)
        
          :type
          (make-node :grammar/type
            :view/expr/juxt)
            
          :separator
          (make-node :view/sequence [
            (make-node :view/expr/keyword {
              :str "," 
            })
            (make-node :view/thickspace)
          ])
        })
      })
      
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/kernel/app)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :clojure/kernel/expr)
      ])

      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :app_expr {
          :name 
          (make-node :grammar/name :clojure/kernel/app/expr)
            
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
              :type :clojure/kernel/expr
            })
          ])
          
          :optional false
        })
        (make-node :grammar/attr :app_args {
          :name 
          (make-node :grammar/name :clojure/kernel/app/args)
            
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
              :type :clojure/kernel/args
            })
          ])
          
          :optional false
        })
      ])
      
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/sequence [
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :app_expr)
            })
          })
          (make-node :view/thinspace)
          (make-node :view/delimited {
            :left "("
            :right ")"
            :content 
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :app_args)
              })
            })
          })
        ])
      })
    })
              
    (make-node :grammar/seqNode {
      :type
      (make-node :grammar/type :clojure/kernel/args)
    
      :supers 
      (make-node :grammar/types [])
      
      :options
      (make-node :grammar/options [
          (make-node :grammar/node {
              :type
              :clojure/kernel/expr
            })
        ])
        
      :min
      0
      
      :display
      (make-node :grammar/seq {
          ; :ref
          ; (ref-node ???)
        
          :type
          (make-node :grammar/type
            :view/expr/juxt)
            
          :separator
          (make-node :view/sequence [
            (make-node :view/expr/keyword {
              :str "," 
            })
            (make-node :view/thickspace)
          ])
        })
    })
    
    
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/kernel/if)
      
      :supers 
      (make-node :grammar/types [
        (make-node :grammar/type :clojure/kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :if_test {
          :name
          (make-node :grammar/name :clojure/kernel/if/test)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type
                :clojure/kernel/expr
              })
          ])
          
          :optional false
        }) 
        (make-node :grammar/attr :if_then {
          :name
          (make-node :grammar/name :clojure/kernel/if/then)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type
                :clojure/kernel/expr
              })
          ])
          
          :optional false
        }) 
        (make-node :grammar/attr :if_else {
          :name
          (make-node :grammar/name :clojure/kernel/if/else)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
          
          :optional false
        }) 
      ])
      
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/expr/flow [
          (make-node :view/expr/keyword { :str "if" })
          (make-node :clojure/kernel/unquote {
            :body 
            (make-node :clojure/kernel/var {
              :ref (ref-node :if_test)
            })
          })
          (make-node :view/expr/keyword { :str "then" })
          (make-node :clojure/kernel/unquote {
            :body 
            (make-node :clojure/kernel/var {
              :ref (ref-node :if_then)
            })
          })
          (make-node :view/expr/keyword { :str "else" })
          (make-node :clojure/kernel/unquote {
            :body 
            (make-node :clojure/kernel/var {
              :ref (ref-node :if_else)
            })
          })
        ])
      })
    })

    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/kernel/let)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :clojure/kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :let_bind {
          :name
          (make-node :grammar/name :clojure/kernel/let/bind)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/bind
              })
          ])
          
          :optional false
        })
        (make-node :grammar/attr :let_expr {
          :name
          (make-node :grammar/name :clojure/kernel/let/expr)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
          
          :optional false
        })
        (make-node :grammar/attr :let_body {
          :name
          (make-node :grammar/name :clojure/kernel/let/body)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
                :type :clojure/kernel/expr
              })
          ])
          
          :optional false
        })
      ])

      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/expr/flow [
          (make-node :view/expr/keyword { :str "let" })
          (make-node :clojure/kernel/unquote {
            :body 
            (make-node :clojure/kernel/var {
              :ref (ref-node :let_bind)
            })
          })
          (make-node :view/expr/symbol { :str "=" })
          (make-node :clojure/kernel/unquote {
            :body 
            (make-node :clojure/kernel/var {
              :ref (ref-node :let_expr)
            })
          })
          (make-node :view/expr/keyword { :str "in" })
          (make-node :clojure/kernel/unquote {
            :body 
            (make-node :clojure/kernel/var {
              :ref (ref-node :let_body)
            })
          })
        ])
      })
    })
      
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/kernel/var)
      
      :supers
      (make-node :grammar/types [ 
        (make-node :grammar/type :clojure/kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :var_ref {
          :name
          (make-node :grammar/name :clojure/kernel/var/ref)
          
          :options
          (make-node :grammar/options [ ; TODO
            ; (make-node :grammar/ref {
            ;   :type :clojure/kernel/bind
            ; })
          ])
          
          :optional false
        })
      ])
    
      :display
      (make-node :clojure/kernel/var {
        :ref (ref-node :var_ref)
      })
    })
        
    ; TODO: loop
    ; TODO: recur
    
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/kernel/quote)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :clojure/kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :quote_body {
          :name
          (make-node :grammar/name :clojure/kernel/quote/body)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
              :type :clojure/kernel/expr
            })
          ])
          
          :optional false
        })
      ])
      
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/expr/embed {
          :content
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :quote_body)
            })
          })
        })
      })
    })
    
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/kernel/unquote)
      
      :supers 
      (make-node :grammar/types [ 
        ; Note: unquote is legal _anywhere_, because the node it evaluates to
        ; can't be checked until evaluation time (unless you have a type system)
        (make-node :grammar/star)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :unquote_body {
          :name
          (make-node :grammar/name :clojure/kernel/unquote/body)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/node {
              :type :clojure/kernel/expr
            })
          ])
          
          :optional false
        })
      ])
      
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/expr/unbed {
          :content
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :unquote_body)
            })
          })
        })
      })
    })
    
    (make-node :grammar/mapNode {
      :type
      (make-node :grammar/type :clojure/kernel/extern)
      
      :supers 
      (make-node :grammar/types [ 
        (make-node :grammar/type :clojure/kernel/expr)
      ])
      
      :attrs
      (make-node :grammar/attrs [
        (make-node :grammar/attr :extern_name {
          :name
          (make-node :grammar/name :clojure/kernel/extern/name)
          
          :options
          (make-node :grammar/options [
            (make-node :grammar/string)
          ])
          
          :optional false
        })
      ])
      
      :display
      (make-node :clojure/kernel/quote {
        :body
        (make-node :view/expr/mono {
          :str
          (make-node :clojure/kernel/unquote {
            :body 
            (make-node :clojure/kernel/var {
              :ref (ref-node :extern_name)
            })
          })
        })
      })
    })

  ])
