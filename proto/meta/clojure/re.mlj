; Regular expression sub-language.

(use 'meta.core)   ; ignored by load-nodes, but should make this file legal Clojure

(make-node :grammar/language [

  ; dot
  (make-node :grammar/mapNode {
    :doc
    (make-node :grammar/doc { :str "Matches any single character" })

    :type
    (make-node :grammar/type :clojure/re/dot)
    
    :supers 
    (make-node :grammar/types [ 
      (make-node :grammar/type :clojure/re/pattern)
    ])
    
    :attrs
    (make-node :grammar/attrs [
    ])
    
    :display
    (make-node :clojure/kernel/quote {
      :body
      (make-node :view/expr/symbol { :str :cdot })
    })
  })

  ; star
  (make-node :grammar/mapNode {
    :doc
    (make-node :grammar/doc { :str "Matches zero or more repeats of the contained pattern" })

    :type
    (make-node :grammar/type :clojure/re/star)
    
    :supers 
    (make-node :grammar/types [ 
      (make-node :grammar/type :clojure/re/pattern)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :star_expr {
        :name
        (make-node :grammar/name :clojure/re/star/expr)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node {
            :type :clojure/re/pattern
          })
        ])
      })
    ])
    
    :display
    (make-node :clojure/kernel/quote {
      :body
      (make-node :view/scripted {
        :nucleus
        (make-node :clojure/kernel/unquote {
          :body
          (make-node :clojure/kernel/var {
            :ref (ref-node :star_expr)
          })
        })

        :super
        (make-node :view/expr/symbol { :str "*" })
      })
    })
  })


  ; repeat
  (make-node :grammar/mapNode {
    :doc
    (make-node :grammar/doc { :str "Matches repeats of the contained pattern" })

    :type
    (make-node :grammar/type :clojure/re/repeat)
    
    :supers 
    (make-node :grammar/types [ 
      (make-node :grammar/type :clojure/re/pattern)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :repeat_expr {
        :name
        (make-node :grammar/name :clojure/re/repeat/expr)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node {
            :type :clojure/re/pattern
          })
        ])
      })
      (make-node :grammar/attr :repeat_min {
        :name
        (make-node :grammar/name :clojure/re/repeat/min)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node {
            :type :clojure/kernel/int
          })
        ])
      })
      (make-node :grammar/attr :repeat_max {
        :name
        (make-node :grammar/name :clojure/re/repeat/max)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node {
            :type :clojure/kernel/int
          })
        ])
      })
    ])
    
    :display
    (make-node :clojure/kernel/quote {
      :body
      (make-node :view/scripted {
        :nucleus
        (make-node :clojure/kernel/unquote {
          :body
          (make-node :clojure/kernel/var {
            :ref (ref-node :repeat_expr)
          })
        })

        :super
        (make-node :view/expr/juxt [
          (make-node :view/expr/int { 
            :str
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :repeat_min)
              })
            })
          })
          (make-node :view/expr/keyword { :str ".." })
          (make-node :view/expr/int { 
            :str
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :repeat_max)
              })
            })
          })
        ])
      })
    })
  })


  ; digit
  (make-node :grammar/mapNode {
    :doc
    (make-node :grammar/doc { :str "Matches a single digit, 0-9" })

    :type
    (make-node :grammar/type :clojure/re/digit)
    
    :supers 
    (make-node :grammar/types [ 
      (make-node :grammar/type :clojure/re/pattern)
    ])
    
    :attrs
    (make-node :grammar/attrs [
    ])
    
    :display
    (make-node :clojure/kernel/quote {
      :body
      (make-node :view/expr/keyword { :str "#" })
    })
  })

  ; sequence
  (make-node :grammar/seqNode {
    :type 
    (make-node :grammar/type :clojure/re/sequence)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :clojure/re/pattern)
    ])

    :options 
    (make-node :grammar/options [
      (make-node :grammar/node {
        :type :clojure/re/pattern
      })
    ])
    
    :min
    (make-node :grammar/count 2)

    :display
    (make-node :grammar/seq {
      :type 
      (make-node :grammar/type :view/expr/binary)
    })
  })
  
  ; option
  (make-node :grammar/seqNode {
    :type 
    (make-node :grammar/type :clojure/re/option)
    
    :supers
    (make-node :grammar/types [
      (make-node :grammar/type :clojure/re/pattern)
    ])

    :options 
    (make-node :grammar/options [
      (make-node :grammar/node {
        :type :clojure/re/pattern
      })
    ])
    
    :min
    (make-node :grammar/count 2)

    :display
    (make-node :grammar/seq {
      :type 
      (make-node :grammar/type :view/expr/binary)
      
      :separator
      (make-node :view/expr/symbol { :str :textpipe })
    })
  })
  
  ; chars
  (make-node :grammar/mapNode {
    :type
    (make-node :grammar/type :clojure/re/chars)
  
    :supers
    (make-node :grammar/types [ 
      (make-node :grammar/type :clojure/re/pattern)
    ])
  
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :chars_str {
        :name
        (make-node :grammar/name :clojure/re/chars/str)

        :options
        (make-node :grammar/options [
          (node :grammar/string)
        ])
    
        :optional
        false
      })
    ])
    
    :display
    (make-node :clojure/kernel/quote {
      :body
      (make-node :view/expr/mono {
        :str
        (make-node :clojure/kernel/unquote {
          :body
          (make-node :clojure/kernel/var {
            :ref (ref-node :chars_str) 
          })
        })
      })
    })
  })
  
])