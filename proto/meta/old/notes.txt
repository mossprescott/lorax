Next steps:
- switch to a representation with explicit nodes (composite) vs. values (atoms)
- get meta-evaluation working (hygiene?)
	- +, -, *, =
	- and, or
- sketch how grammar rules are defined
	- a (flat) set of productions
	- arbitrary code?
	- a simple, declarative way for most purposes
	- compositional?
- sketch how other static checks work
	- say, a type-checker?
	- what happens with extensions?
	- can you plug in a function to compute the type of a node?
- start thinking about presentation
	- use typography, color, etc. to distinguish literals, names, operators, syntax, etc.
		- names most prominent
		- but different when used different ways
		- use correct math symbol when meaning is same (sets, lists)
		- use single-letter names as defaults (x, y, z for args, i, j, k for loops, etc.)
		- auto-disambiguation
		- show values of simple lets, instead of a name?
	- parens: LISP, C, or Haskell? a switch?
	- a new language? 
		- maybe based on Clojure semantics, but with different feel?
		- support for functional idioms
		- maybe more like Haskell's syntax?
		- "let a = 1", with multiple, serial bindings
		- "-> % + 1", or "+", or "\x -> x + 1"
	- or does it make more sense to use a real language?
		- Java?
	- needs to be simple for simple extensions
		- new keywords, statements
		- new kinds of list constructors, etc.
		- floor, ceil, abs, etc.
	- more complex extensions:
		- arbitrary glyphs (sqrt?)
		- novel constructors: matrix, vector, etc.
		- special layout: fancy conditionals?
		- sub-languages: regex?