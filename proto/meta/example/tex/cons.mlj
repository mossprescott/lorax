(use 'meta.core)  ; ignored by load-nodes, but should make this file legal Clojure

(make-node :grammar/language [
  ; cons (primitive)
  (make-node :grammar/mapNode {
    ; :doc
    ; (make-node :grammar/doc { :str "[primitive] New lazy sequence by appending an element to a sequence. The sequence is not evaluated until it is accessed." })
    
    :type
    (make-node :grammar/type :core/cons)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :cons_first {
        :name
        (make-node :grammar/name :core/cons/first)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node {
              :type
              :kernel/expr
            })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :cons_rest {
        :name
        (make-node :grammar/name :core/cons/rest)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node {
              :type
              :kernel/expr
            })
        ])
        
        :optional false
      }) 
    ])
    
    :display
    (make-node :kernel/quote {
      :body
      (make-node :view/expr/relation [
        (make-node :kernel/unquote {
          :body
          (make-node :kernel/var {
           :ref
           (ref-node :cons_first) 
          })
        })
        (make-node :view/expr/keyword { :str ":" })
        (make-node :kernel/unquote {
          :body
          (make-node :kernel/var {
           :ref
           (ref-node :cons_rest) 
          })
        })
      ])
    })
    
    :expand
    (make-node :kernel/quote {
      :body
      (make-node :kernel/app {
        :expr
        (make-node :kernel/extern { :name "cons" })
        
        :args
        (make-node :kernel/args [
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
             :ref
             (ref-node :cons_first) 
            })
          })
          (make-node :kernel/app {
            :expr
            (make-node :kernel/extern { :name "lazy-seq" })
        
            :args
            (make-node :kernel/args [
              (make-node :kernel/unquote {
                :body
                (make-node :kernel/var {
                 :ref
                 (ref-node :cons_rest) 
                })
              })
            ])
          })
        ])
      })
    })
  })

  ; match-cons
  (make-node :grammar/mapNode {
    ; :doc
    ; (make-node :grammar/doc { :str "" })
    
    :type
    (make-node :grammar/type :core/match-cons)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :match-cons_expr {
        :name
        (make-node :grammar/name :core/match-cons/expr)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-cons_first {
        :name
        (make-node :grammar/name :core/match-cons/first)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/bind })
        ])
        
        :optional false
      })
      (make-node :grammar/attr :match-cons_rest {
        :name
        (make-node :grammar/name :core/match-cons/rest)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/bind })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-cons_body {
        :name
        (make-node :grammar/name :core/match-cons/body)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-cons_else {
        :name
        (make-node :grammar/name :core/match-cons/else)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
    ])
    
    :display
    (make-node :kernel/quote {
      :body
      (make-node :view/expr/flow [
        (make-node :view/expr/keyword { :str "match" })
        (make-node :kernel/unquote {
          :body
          (make-node :kernel/var {
           :ref (ref-node :match-cons_expr) 
          })
        })
        (make-node :view/expr/keyword { :str "with" })
        (make-node :view/expr/relation [
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
             :ref (ref-node :match-cons_first) 
            })
          })
          (make-node :view/expr/keyword { :str ":" })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
             :ref (ref-node :match-cons_rest) 
            })
          })
        ])
        (make-node :view/expr/symbol { :str :to })
        (make-node :kernel/unquote {
          :body
          (make-node :kernel/var {
           :ref (ref-node :match-cons_body) 
          })
        })
        (make-node :view/expr/keyword { :str "else" })
        (make-node :kernel/unquote {
          :body
          (make-node :kernel/var {
           :ref (ref-node :match-cons_else) 
          })
        })
      ])
    })
    
    :expand
    (make-node :kernel/quote {
      :body
      ; (make-node :core/where {
      (make-node :core/let2 {
        :bind
        (make-node :kernel/bind :match-cons_x { :name "x" })
        
        :expr
        (make-node :kernel/unquote {
          :body
          (make-node :kernel/var {
           :ref (ref-node :match-cons_expr) 
          })
        })

        :body
        (make-node :kernel/if {
          :test
          (make-node :kernel/app {
            :expr
            (make-node :kernel/extern { :name "seq" })
            
            :args
            (make-node :kernel/args [
              (make-node :kernel/var {
               :ref (ref-node :match-cons_x) 
              })
            ])
          })
        
          :then
          (make-node :core/where {
            
          ; (make-node :kernel/let {
          ;   :bind
          ;   (make-node :kernel/unquote {
          ;     :body
          ;     (make-node :kernel/var {
          ;      :ref (ref-node :match-cons_first) 
          ;     })
          ;   })
          ;   
          ;   :expr
          ;   (make-node :kernel/app {
          ;     :expr
          ;     (make-node :kernel/extern { :name "first" })
          ;   
          ;     :args
          ;     (make-node :kernel/args [
          ;       (make-node :kernel/var {
          ;        :ref (ref-node :match-cons_x) 
          ;       })
          ;     ])
          ;   })
          ;   
          ;   :body
          ;   (make-node :kernel/let {
          ;     :bind
          ;     (make-node :kernel/unquote {
          ;       :body
          ;       (make-node :kernel/var {
          ;        :ref (ref-node :match-cons_rest) 
          ;       })
          ;     })
          ;   
          ;     :expr
          ;     (make-node :kernel/app {
          ;       :expr
          ;       (make-node :kernel/extern { :name "rest" })
          ;   
          ;       :args
          ;       (make-node :kernel/args [
          ;         (make-node :kernel/var {
          ;          :ref (ref-node :match-cons_x) 
          ;         })
          ;       ])
          ;     })
            
            :body
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
               :ref (ref-node :match-cons_body) 
              })
            })
            
            :vars
            (make-node :core/whereVars [
              (make-node :core/whereVar {
                :bind
                (make-node :kernel/unquote {
                  :body
                  (make-node :kernel/var {
                   :ref (ref-node :match-cons_first) 
                  })
                })
            
                :expr
                (make-node :kernel/app {
                  :expr
                  (make-node :kernel/extern { :name "first" })
            
                  :args
                  (make-node :kernel/args [
                    (make-node :kernel/var {
                     :ref (ref-node :match-cons_x) 
                    })
                  ])
                })
              })

              (make-node :core/whereVar {
                :bind
                (make-node :kernel/unquote {
                  :body
                  (make-node :kernel/var {
                   :ref (ref-node :match-cons_rest) 
                  })
                })
          
                :expr
                (make-node :kernel/app {
                  :expr
                  (make-node :kernel/extern { :name "rest" })
          
                  :args
                  (make-node :kernel/args [
                    (make-node :kernel/var {
                     :ref (ref-node :match-cons_x) 
                    })
                  ])
                })
              })
            ])
          })
        
          :else
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
             :ref (ref-node :match-cons_else) 
            })
          })
        })
        
        ; :vars
        ; (make-node :core/whereVars [
        ;   (make-node :core/whereVar {
        ;     :bind
        ;     (make-node :kernel/bind :match-cons_x { :name "x" })
        ;     
        ;     :expr
        ;     (make-node :kernel/unquote {
        ;       :body
        ;       (make-node :kernel/var {
        ;        :ref (ref-node :match-cons_expr) 
        ;       })
        ;     })
        ;   })
        ; ])
      })
    })
  })

  ; for
  (make-node :grammar/mapNode {
    ; :doc
    ; (make-node :grammar/doc { :str "Sequence comprehension, with a single binding" })
    
    :type
    (make-node :grammar/type :core/for)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :for_x {
        :name
        (make-node :grammar/name :core/for/x)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node {
              :type
              :kernel/bind
            })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :for_seq {
        :name
        (make-node :grammar/name :core/for/seq)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node {
              :type
              :kernel/expr
            })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :for_expr {
        :name
        (make-node :grammar/name :core/for/expr)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node {
              :type
              :kernel/expr
            })
        ])
        
        :optional false
      }) 
    ])
    
    :display
    (make-node :kernel/quote {
      :body
      (make-node :view/expr/flow [
        (make-node :kernel/unquote {
          :body
          (make-node :kernel/var {
            :ref (ref-node :for_expr)
          })
        })        
        (make-node :view/expr/symbol { :str "|" })
        (make-node :kernel/unquote {
          :body
          (make-node :kernel/var {
            :ref (ref-node :for_x)
          })
        })
        (make-node :view/expr/symbol { :str :from })
        (make-node :kernel/unquote {
          :body
          (make-node :kernel/var {
            :ref (ref-node :for_seq)
          })
        })
      ])
    })
    
    :expand
    (make-node :kernel/quote {
      :body
      (make-node :core/where {
        :body
        (make-node :kernel/app {
          :expr
          (make-node :kernel/var {
            :ref (ref-node :for0)
          })
        
          :args 
          (make-node :kernel/args [
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :for_seq)
              })
            })
          ])
        })

        :vars
        (make-node :core/whereVars [
          (make-node :core/whereVar {
            :bind
            (make-node :kernel/bind :for0 { :name "f" })
      
            :expr
            (make-node :kernel/lambda :f_for {
              :params 
              (make-node :kernel/params [
                (make-node :kernel/bind :for1 { :name "s" })
              ])
        
              :body
              (make-node :core/match-cons {
                :expr
                (make-node :kernel/var {
                  :ref (ref-node :for1)
                })

                :first
                (make-node :kernel/unquote {
                  :body
                  (make-node :kernel/var {
                    :ref (ref-node :for_x)
                  })
                })

                :rest
                (make-node :kernel/bind :for_xs { :name "xs" })
            
                :body
                (make-node :core/cons {
                  :first
                  (make-node :kernel/unquote {
                    :body
                    (make-node :kernel/var {
                      :ref (ref-node :for_expr)
                    })
                  })
            
                  :rest
                  (make-node :kernel/app {
                    :expr
                    (make-node :kernel/var {
                      :ref (ref-node :f_for)
                    })
              
                    :args
                    (make-node :kernel/params [
                      (make-node :kernel/var {
                        :ref (ref-node :for_xs)
                      })
                    ])
                  })
                })

                :else
                (make-node :kernel/nil)
              })
            })
          })
        ])
      })
    })
  })
])