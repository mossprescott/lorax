(use 'meta.core)

(make-node :core/program [

  (make-node :core/where {
    :body
    ; (make-node :core/take {
    ;   :count
    ;   (make-node :kernel/int { :value 10 })
    ;   
    ;   :seq
    ;   (make-node :kernel/var {
    ;     :ref (ref-node :ratios)
    ;   })
    ; })

    (make-node :core/for {
      :expr
      (make-node :core/nth {
        :expr
        (make-node :kernel/var {
          :ref (ref-node :rationals)
        })
        
        :index
        (make-node :kernel/var {
          :ref (ref-node :i)
        })
      })
      
      :x
      (make-node :kernel/bind :i { :name "i" })
      
      :seq
      (make-node :core/range {
        :min
        (make-node :kernel/int { :value 0 })
    
        :max
        (make-node :kernel/int { :value 14 })
      })
    })

    ; (make-node :kernel/app {
    ;   :expr
    ;   (make-node :kernel/var {
    ;     :ref (ref-node :next)
    ;   })
    ;   
    ;   :args 
    ;   (make-node :kernel/args [
    ;     (make-node :cf/fraction {
    ;       :coeff
    ;       (make-node :kernel/int { :value 1 })
    ;       
    ;       :cont
    ;       (make-node :cf/inf)
    ;     })
    ;     ; (make-node :cf/fraction {
    ;     ;   :coeff
    ;     ;   (make-node :kernel/int { :value 0 })
    ;     ;   
    ;     ;   :cont
    ;     ;   (make-node :cf/fraction {
    ;     ;     :coeff
    ;     ;     (make-node :kernel/int { :value 2 })
    ;     ;   
    ;     ;     :cont
    ;     ;     (make-node :cf/inf)
    ;     ;   })
    ;     ; })
    ;   ])
    ; })
    
    :vars
    (make-node :core/whereVars [
      (make-node :core/whereVar {
        :bind 
        (make-node :kernel/bind :rationals { :name "rationals" })
        
        :expr
        (make-node :core/iterate {
          :fn
          (make-node :kernel/var {
            :ref (ref-node :next)
          })
          
          :expr
          (make-node :cf/fraction {
            :coeff
            (make-node :kernel/int { :value 1 })
            
            :cont
            (make-node :cf/inf)
          })
        })
      })
      (make-node :core/whereVar {
        :bind 
        (make-node :kernel/bind :next { :name "next" })
        
        :expr
        (make-node :kernel/lambda {
          :params
          (make-node :kernel/params [
            (make-node :kernel/bind :x { :name "x" })
          ])
          
          :body
          (make-node :cf/recip {
            :expr
            (make-node :cf/plus {
              :int
              (make-node :core/plus {
                :left
                (make-node :cf/ip {
                  :expr
                  (make-node :kernel/var {
                    :ref (ref-node :x)
                  })
                })
                
                :right
                (make-node :kernel/int { :value 1 })
              })
              
              :cf
              (make-node :cf/negate {
                :expr
                (make-node :cf/fp {
                  :expr
                  (make-node :kernel/var {
                    :ref (ref-node :x)
                  })
                })
              })
            })
          })
        })
      })
    ])
  })
  
])
