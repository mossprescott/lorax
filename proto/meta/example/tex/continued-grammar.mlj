(use 'meta.core)  ; ignored by load-nodes, but should make this file legal Clojure

(make-node :grammar/language [

  ; inf
  (make-node :grammar/mapNode {
    :doc 
    (make-node :grammar/doc { :str "'nil' fraction value, mathematically equal to infinity." })
    
    :type
    (make-node :grammar/type :cf/inf)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [])
    
    :display
    (make-node :kernel/quote {
      :body
      (make-node :view/expr/symbol { :str :circ })
    })
    
    :expand
    (make-node :kernel/quote {
      :body
      (make-node :core/makeNode {
        :type
        (make-node :kernel/name { :value :cf/inf })
        
        :content
        (make-node :core/noAttrs)
      })
    })
  })
  
  ; fraction
  (make-node :grammar/mapNode {
    :doc 
    (make-node :grammar/doc { :str "Continued fraction constructor, with coefficient (an int at runtime) and continuation (a cont. fraction, or inf)." })
    
    :type
    (make-node :grammar/type :cf/fraction)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :cf_coeff {
        :name
        (make-node :grammar/name :cf/fraction/coeff)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :cf_cont {
        :name
        (make-node :grammar/name :cf/fraction/cont)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
    ])
    
    :display
    (make-node :kernel/quote {
      :body
      (make-node :view/expr/relation [
        (make-node :kernel/unquote {
          :body
          (make-node :kernel/var {
           :ref (ref-node :cf_coeff) ; HACK
          })
        })
        (make-node :view/expr/symbol { :str "+" })
        ; Note: need a conditional to render the nullary continuation specially:
        (make-node :kernel/unquote {
          :body
          (make-node :kernel/if {
            :test
            ; (make-node :core/missing? {
            ;   :node
            ;   (make-node :kernel/var {
            ;     :ref (ref-node :cf_cont)
            ;   })
            ; })
            (make-node :core/equal {
              :left
              (make-node :kernel/var {
                :ref (ref-node :cf_cont)
              })
              
              :right
              ; (make-node :kernel/quote {
              ;   :body
                (make-node :cf/inf)
              ; })
            })
            
            :then
            (make-node :kernel/var {
             :ref (ref-node :cf_cont) 
            })
            ; (make-node :kernel/quote {
            ;   :body
            ;   (make-node :view/expr/symbol { :str :circ })
            ; })
            
            :else
            (make-node :kernel/quote {
              :body
              (make-node :view/over {
                :top
                (make-node :kernel/int { :value 1 })
                    
                :weight 1
                  
                :bottom
                (make-node :kernel/unquote {
                  :body
                  (make-node :kernel/var {
                   :ref (ref-node :cf_cont) 
                  })
                })
              })
            })
          })
        })
      ])
    })
    
    :expand  ; evaluates the sub-components and constructs a run-time node!
    (make-node :kernel/quote {
      :body
      (make-node :core/makeNode {
        :type
        (make-node :kernel/name { :value :cf/fraction })
        
        :content
        (make-node :core/nodeAttrs [
          (make-node :core/nodeAttr {
            :name
            (make-node :kernel/name { :value :coeff })
            
            :value
            (make-node :core/unread {
              :node
              (make-node :kernel/unquote {
                :body
                (make-node :kernel/var {
                 :ref (ref-node :cf_coeff) 
                })
              })
            })
          })
          (make-node :core/nodeAttr {
            :name
            (make-node :kernel/name { :value :cont })
            
            :value
            (make-node :core/unread {
              :node
              (make-node :kernel/unquote {
                :body
                (make-node :kernel/var {
                 :ref (ref-node :cf_cont) 
                })
              })
            })
          })
        ])
      })
    })
    
    ; (make-node :kernel/if {
    ;   :test
    ;   (make-node :core/missing? {
    ;     :node
    ;     (make-node :kernel/var {
    ;      :ref (ref-node :cf_cont) 
    ;     })
    ;   })
    ;   
    ;   :then
    ;   (make-node :kernel/quote {
    ;     :body
    ;     ; Tricky! double-quotation doesn't work because I reduce the node under 
    ;     ; the quote. There's probably an answer (a form of quotation that 
    ;     ; blocks reduction?), but for now a hack.
    ;     ; TODO: at least add some simpler syntax for doing this.
    ;     (make-node :kernel/app {
    ;       :expr
    ;       (make-node :kernel/extern { :name "meta.core/make-node"})
    ;     
    ;       :args 
    ;       (make-node :kernel/args [
    ;         (make-node :kernel/name { :value :cf/fraction })
    ;         (make-node :kernel/app {
    ;           :expr
    ;           (make-node :kernel/extern { :name "hash-map"})
    ;       
    ;           :args 
    ;           (make-node :kernel/args [
    ;             (make-node :kernel/name { :value :coeff })
    ;   
    ;             ; Tricky: the value of the attribute may need to be unread back into a node:
    ;             (make-node :kernel/app {
    ;               :expr
    ;               (make-node :kernel/extern { :name "meta.clojure.kernel/unread"})
    ;       
    ;               :args 
    ;               (make-node :kernel/args [
    ;                 (make-node :kernel/unquote {
    ;                   :body
    ;                   (make-node :kernel/var {
    ;                    :ref (ref-node :cf_coeff) 
    ;                   })
    ;                 })
    ;               ])
    ;             })
    ;           ])
    ;         })
    ;       ])
    ;     })
    ;   })
    ;           
    ;   :else
    ;   (make-node :kernel/quote {
    ;     :body
    ;     ; Tricky! double-quotation doesn't work because I reduce the node under 
    ;     ; the quote. There's probably an answer (a form of quotation that 
    ;     ; blocks reduction?), but for now a hack.
    ;     ; TODO: at least add some simpler syntax for doing this.
    ;     (make-node :kernel/app {
    ;       :expr
    ;       (make-node :kernel/extern { :name "meta.core/make-node"})
    ;     
    ;       :args 
    ;       (make-node :kernel/args [
    ;         (make-node :kernel/name { :value :cf/fraction })
    ;         (make-node :kernel/app {
    ;           :expr
    ;           (make-node :kernel/extern { :name "hash-map"})
    ;             
    ;           :args 
    ;           (make-node :kernel/args [
    ;             (make-node :kernel/name { :value :coeff })
    ;   
    ;             ; Tricky: the value of the attribute may need to be unread back into a node:
    ;             (make-node :kernel/app {
    ;               :expr
    ;               (make-node :kernel/extern { :name "meta.clojure.kernel/unread"})
    ;     
    ;               :args 
    ;               (make-node :kernel/args [
    ;                 (make-node :kernel/unquote {
    ;                   :body
    ;                   (make-node :kernel/var {
    ;                    :ref (ref-node :cf_coeff) 
    ;                   })
    ;                 })
    ;               ])
    ;             })
    ;   
    ;             ; TODO: handle missing :cont
    ;             (make-node :kernel/name { :value :cont })
    ;   
    ;             ; Tricky: the value of the attribute may need to be unread back into a node:
    ;             (make-node :kernel/app {
    ;               :expr
    ;               (make-node :kernel/extern { :name "meta.clojure.kernel/unread"})
    ;     
    ;               :args 
    ;               (make-node :kernel/args [
    ;                 (make-node :kernel/unquote {
    ;                   :body
    ;                   (make-node :kernel/var {
    ;                    :ref (ref-node :cf_cont) 
    ;                   })
    ;                 })
    ;               ])
    ;             })
    ;           ])
    ;         })
    ;       ])
    ;     })
    ;   })
    
      ; (make-node :kernel/quote {
      ;   :body
      ;   (make-node :kernel/nil)
      ;   ; (make-node :core/continuedFraction {
      ;   ;   :coeff
      ;   ;   (make-node :kernel/int { :value 2 })
      ;   ; ;   (make-node :kernel/unquote {
      ;   ; ;     :body
      ;   ; ;     (make-node :kernel/unquote {
      ;   ; ;       :body
      ;   ; ;       (make-node :kernel/var {
      ;   ; ;        :ref (ref-node :cf_coeff) 
      ;   ; ;       })
      ;   ; ;     })
      ;   ; ;   })
      ;   ; ; 
      ;   ;   :cont
      ;   ;   (make-node :kernel/int { :value 3 })
      ;   ; ;   (make-node :kernel/unquote {
      ;   ; ;     :body
      ;   ; ;     (make-node :kernel/unquote {
      ;   ; ;       :body
      ;   ; ;       (make-node :kernel/var {
      ;   ; ;        :ref (ref-node :cf_cont) 
      ;   ; ;       })
      ;   ; ;     })
      ;   ; ;   })
      ;   ; })
      ; })
  })

  ; ; match-v
  ; (make-node :grammar/mapNode {
  ;   :doc 
  ;   (make-node :grammar/doc { :str "Pattern-match for a fraction with no continuation (i.e. representing an integer)" })
  ;   
  ;   :type
  ;   (make-node :grammar/type :cf/match-v)
  ;   
  ;   :supers 
  ;   (make-node :grammar/types [
  ;     (make-node :grammar/type :kernel/expr)
  ;   ])
  ;   
  ;   :attrs
  ;   (make-node :grammar/attrs [
  ;     (make-node :grammar/attr :match-v_expr {
  ;       :name
  ;       (make-node :grammar/name :cf/match-v/expr)
  ;       
  ;       :options
  ;       (make-node :grammar/options [
  ;         (make-node :grammar/node { :type :kernel/expr })
  ;       ])
  ;       
  ;       :optional false
  ;     }) 
  ;     (make-node :grammar/attr :match-v_coeff {
  ;       :name
  ;       (make-node :grammar/name :cf/match-v/coeff)
  ;       
  ;       :options
  ;       (make-node :grammar/options [
  ;         (make-node :grammar/node { :type :kernel/bind })
  ;       ])
  ;       
  ;       :optional false
  ;     }) 
  ;     (make-node :grammar/attr :match-v_then {
  ;       :name
  ;       (make-node :grammar/name :cf/match-v/then)
  ;       
  ;       :options
  ;       (make-node :grammar/options [
  ;         (make-node :grammar/node { :type :kernel/expr })
  ;       ])
  ;       
  ;       :optional false
  ;     }) 
  ;     (make-node :grammar/attr :match-v_else {
  ;       :name
  ;       (make-node :grammar/name :cf/match-v/else)
  ;       
  ;       :options
  ;       (make-node :grammar/options [
  ;         (make-node :grammar/node { :type :kernel/expr })
  ;       ])
  ;       
  ;       :optional false
  ;     }) 
  ;   ])
  ;   
  ;   :display
  ;   (make-node :kernel/quote {
  ;     :body
  ;     (make-node :view/section [
  ;       (make-node :view/expr/flow [
  ;         (make-node :view/expr/keyword { :str "match" })
  ;         (make-node :kernel/unquote {
  ;           :body
  ;           (make-node :kernel/var {
  ;             :ref (ref-node :match-v_expr)
  ;           })
  ;         })
  ;         (make-node :view/expr/symbol { :str "|" })
  ;         (make-node :view/expr/binary [
  ;           (make-node :kernel/unquote {
  ;             :body
  ;             (make-node :kernel/var {
  ;               :ref (ref-node :match-v_coeff)
  ;             })
  ;           })
  ;           (make-node :view/expr/symbol { :str "+" })
  ;           (make-node :view/expr/symbol { :str :circ })
  ;         ])
  ;         (make-node :view/expr/symbol { :str :to })
  ;         (make-node :kernel/unquote {
  ;           :body
  ;           (make-node :kernel/var {
  ;             :ref (ref-node :match-v_then)
  ;           })
  ;         })
  ;       ])        
  ;       (make-node :view/expr/flow [
  ;         (make-node :view/sequence []) ; empty, so there's just one quad of indent
  ;         (make-node :view/expr/keyword { :str "else" })
  ;         (make-node :kernel/unquote {
  ;           :body
  ;           (make-node :kernel/var {
  ;             :ref (ref-node :match-v_else)
  ;           })
  ;         })
  ;       ])
  ;     ])
  ;   })
  ;   
  ;   :expand
  ;   (make-node :kernel/quote {
  ;     :body
  ;     (make-node :kernel/let {
  ;       :bind 
  ;       (make-node :kernel/bind :x_match-v { :name "x" })
  ; 
  ;       :expr
  ;       (make-node :kernel/unquote {
  ;         :body
  ;         (make-node :kernel/var {
  ;           :ref (ref-node :match-v_expr)
  ;         })
  ;       })
  ;       
  ;       :body
  ;       (make-node :kernel/if {
  ;         :test
  ;         (make-node :core/and {
  ;           :left  ; is a cf node
  ;           (make-node :core/equal {
  ;             :left
  ;             (make-node :core/type {
  ;               :node
  ;               (make-node :kernel/var {
  ;                 :ref (ref-node :x_match-v)
  ;               })
  ;             })
  ;             
  ;             :right
  ;             (make-node :kernel/name { :value :cf/fraction })
  ;           })
  ; 
  ;           :right  ; does _not_ have a cont. attr
  ;           (make-node :core/not {
  ;             :expr
  ;             (make-node :core/has? {
  ;               :node 
  ;               (make-node :kernel/var {
  ;                 :ref (ref-node :x_match-v)
  ;               })
  ;           
  ;               :name
  ;               (make-node :kernel/name { :value :cont })
  ;             })
  ;           })
  ;         })
  ;       
  ;         :then
  ;         (make-node :kernel/let {
  ;           :bind 
  ;           (make-node :kernel/unquote {
  ;             :body
  ;             (make-node :kernel/var {
  ;               :ref (ref-node :match-v_coeff)
  ;             })
  ;           })
  ;           
  ;           :expr
  ;           (make-node :core/eval {
  ;             :node
  ;             (make-node :core/attr {
  ;               :node 
  ;               (make-node :kernel/var {
  ;                 :ref (ref-node :x_match-v)
  ;               })
  ;           
  ;               :name
  ;               (make-node :kernel/name { :value :coeff })
  ;             })
  ;           })
  ; 
  ;           :body
  ;           (make-node :kernel/unquote {
  ;             :body
  ;             (make-node :kernel/var {
  ;               :ref (ref-node :match-v_then)
  ;             })
  ;           })
  ;         })
  ;       
  ;         :else
  ;         (make-node :kernel/unquote {
  ;           :body
  ;           (make-node :kernel/var {
  ;             :ref (ref-node :match-v_else)
  ;           })
  ;         })
  ;       })
  ;     })
  ;   })
  ; })

  ; match-x
  (make-node :grammar/mapNode {
    :doc 
    (make-node :grammar/doc { :str "Pattern-match for a fraction with no continuation and arbitrary coefficient" })
    
    :type
    (make-node :grammar/type :cf/match-x)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :match-x_expr {
        :name
        (make-node :grammar/name :cf/match-x/expr)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-x_x {
        :name
        (make-node :grammar/name :cf/match-x/x)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/bind })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-x_then {
        :name
        (make-node :grammar/name :cf/match-x/then)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-x_else {
        :name
        (make-node :grammar/name :cf/match-x/else)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
    ])
    
    :display
    (make-node :kernel/quote {
      :body
      (make-node :view/section [
        (make-node :view/expr/flow [
          (make-node :view/expr/keyword { :str "match" })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-x_expr)
            })
          })
        ])
        (make-node :view/expr/flow [
          (make-node :view/sequence []) ; empty, so there's just one quad of indent
          ; (make-node :view/expr/symbol { :str "|" })
          (make-node :view/expr/binary [
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :match-x_x)
              })
            })
            (make-node :view/expr/symbol { :str "+" })
            (make-node :view/expr/symbol { :str :circ })
            ; (make-node :view/over {
            ;   :top
            ;   (make-node :kernel/int { :value 1 })
            ;   
            ;   :weight 1
            ;   
            ;   :bottom
            ;   (make-node :kernel/unquote {
            ;     :body
            ;     (make-node :kernel/var {
            ;       :ref (ref-node :match-vc_cont)
            ;     })
            ;   })
            ; })
          ])
          (make-node :view/expr/symbol { :str :to })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-x_then)
            })
          })
        ])
        (make-node :view/expr/flow [
          (make-node :view/sequence []) ; empty, so there's just one quad of indent
          (make-node :view/expr/keyword { :str "else" })
          (make-node :view/expr/symbol { :str :to })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-x_else)
            })
          })
        ])
      ])
    })
    
    :expand
    (make-node :kernel/quote {
      :body
      (make-node :kernel/let {
        :bind 
        (make-node :kernel/bind :x_match-x { :name "c" })

        :expr
        (make-node :kernel/unquote {
          :body
          (make-node :kernel/var {
            :ref (ref-node :match-x_expr)
          })
        })
        
        :body
        (make-node :kernel/if {
          :test
          (make-node :core/and {
            :left  ; is a cf node
            (make-node :core/equal {
              :left
              (make-node :core/type {
                :node
                (make-node :kernel/var {
                  :ref (ref-node :x_match-x)
                })
              })
              
              :right
              (make-node :kernel/name { :value :cf/fraction })
            })

            ; :right
            ; (make-node :core/and {
            ;   :left  ; coeff. matches the given expr
            ;   (make-node :core/equal {
            ;     :left
            ;     (make-node :kernel/unquote {
            ;       :body
            ;       (make-node :kernel/var {
            ;         :ref (ref-node :match-v_coeff)
            ;       })
            ;     })
            ;     
            ;     :right
            ;     (make-node :core/eval {
            ;       :node
            ;       (make-node :core/attr {
            ;         :node 
            ;         (make-node :kernel/var {
            ;           :ref (ref-node :x_match-x)
            ;         })
            ;                 
            ;         :name
            ;         (make-node :kernel/name { :value :coeff })
            ;       })
            ;     })
            ;   })

              :right  ; cont. is inf
              (make-node :core/equal {
                :left
                (make-node :core/attr {
                  :node
                  (make-node :kernel/var {
                    :ref (ref-node :x_match-x)
                  })
          
                  :name
                  (make-node :kernel/name { :value :cont })
                })
                
                :right
                (make-node :cf/inf)
              })
            ; })
          })
          
          :then
          (make-node :kernel/let {
            :bind
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :match-x_x)
              })
            })
            
            :expr
            (make-node :core/eval {
              :node
              (make-node :core/attr {
                :node 
                (make-node :kernel/var {
                  :ref (ref-node :x_match-x)
                })
            
                :name
                (make-node :kernel/name { :value :coeff })
              })
            })
            
            :body
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :match-x_then)
              })
            })
          })
          
          :else
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-x_else)
            })
          })
        })
      })
    })
  })
    
  ; match-v
  (make-node :grammar/mapNode {
    :doc 
    (make-node :grammar/doc { :str "Pattern-match for a fraction with no continuation and a specific coefficient (i.e. an integer)" })
    
    :type
    (make-node :grammar/type :cf/match-v)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :match-v_expr {
        :name
        (make-node :grammar/name :cf/match-v/expr)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-v_coeff {
        :name
        (make-node :grammar/name :cf/match-v/coeff)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-v_then {
        :name
        (make-node :grammar/name :cf/match-v/then)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-v_else {
        :name
        (make-node :grammar/name :cf/match-v/else)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
    ])
    
    :display
    (make-node :kernel/quote {
      :body
      (make-node :view/section [
        (make-node :view/expr/flow [
          (make-node :view/expr/keyword { :str "match" })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-v_expr)
            })
          })
        ])
        (make-node :view/expr/flow [
          (make-node :view/sequence []) ; empty, so there's just one quad of indent
          ; (make-node :view/expr/symbol { :str "|" })
          (make-node :view/expr/binary [
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :match-v_coeff)
              })
            })
            (make-node :view/expr/symbol { :str "+" })
            (make-node :view/expr/symbol { :str :circ })
            ; (make-node :view/over {
            ;   :top
            ;   (make-node :kernel/int { :value 1 })
            ;   
            ;   :weight 1
            ;   
            ;   :bottom
            ;   (make-node :kernel/unquote {
            ;     :body
            ;     (make-node :kernel/var {
            ;       :ref (ref-node :match-vc_cont)
            ;     })
            ;   })
            ; })
          ])
          (make-node :view/expr/symbol { :str :to })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-v_then)
            })
          })
        ])
        (make-node :view/expr/flow [
          (make-node :view/sequence []) ; empty, so there's just one quad of indent
          (make-node :view/expr/keyword { :str "else" })
          (make-node :view/expr/symbol { :str :to })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-v_else)
            })
          })
        ])
      ])
    })
    
    :expand
    (make-node :kernel/quote {
      :body
      (make-node :kernel/let {
        :bind 
        (make-node :kernel/bind :x_match-v { :name "x" })

        :expr
        (make-node :kernel/unquote {
          :body
          (make-node :kernel/var {
            :ref (ref-node :match-v_expr)
          })
        })
        
        :body
        (make-node :kernel/if {
          :test
          (make-node :core/and {
            :left  ; is a cf node
            (make-node :core/equal {
              :left
              (make-node :core/type {
                :node
                (make-node :kernel/var {
                  :ref (ref-node :x_match-v)
                })
              })
              
              :right
              (make-node :kernel/name { :value :cf/fraction })
            })

            :right
            (make-node :core/and {
              :left  ; coeff. matches the given expr
              (make-node :core/equal {
                :left
                (make-node :kernel/unquote {
                  :body
                  (make-node :kernel/var {
                    :ref (ref-node :match-v_coeff)
                  })
                })
                
                :right
                (make-node :core/eval {
                  :node
                  (make-node :core/attr {
                    :node 
                    (make-node :kernel/var {
                      :ref (ref-node :x_match-v)
                    })
            
                    :name
                    (make-node :kernel/name { :value :coeff })
                  })
                })
              })

              :right  ; cont. is inf
              (make-node :core/equal {
                :left
                (make-node :core/attr {
                  :node
                  (make-node :kernel/var {
                    :ref (ref-node :x_match-v)
                  })
          
                  :name
                  (make-node :kernel/name { :value :cont })
                })
                
                :right
                (make-node :cf/inf)
              })
            })
          })
          
          :then
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-v_then)
            })
          })

          :else
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-v_else)
            })
          })
        })
      })
    })
  })
    
  ; match-xc
  (make-node :grammar/mapNode {
    :doc 
    (make-node :grammar/doc { :str "Pattern-match for a fraction with arbitrary coefficient and continuation." })
    
    :type
    (make-node :grammar/type :cf/match-xc)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :match-xc_expr {
        :name
        (make-node :grammar/name :cf/match-xc/expr)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-xc_coeff {
        :name
        (make-node :grammar/name :cf/match-xc/coeff)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/bind })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-xc_cont {
        :name
        (make-node :grammar/name :cf/match-xc/cont)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/bind })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-xc_then {
        :name
        (make-node :grammar/name :cf/match-xc/then)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-xc_else {
        :name
        (make-node :grammar/name :cf/match-xc/else)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
    ])
    
    :display
    (make-node :kernel/quote {
      :body
      (make-node :view/section [
        (make-node :view/expr/flow [
          (make-node :view/expr/keyword { :str "match" })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-xc_expr)
            })
          })
        ])
        (make-node :view/expr/flow [
          (make-node :view/sequence []) ; empty, so there's just one quad of indent
          ; (make-node :view/expr/symbol { :str "|" })
          (make-node :view/expr/binary [
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :match-xc_coeff)
              })
            })
            (make-node :view/expr/symbol { :str "+" })
            (make-node :view/over {
              :top
              (make-node :kernel/int { :value 1 })
              
              :weight 1
              
              :bottom
              (make-node :kernel/unquote {
                :body
                (make-node :kernel/var {
                  :ref (ref-node :match-xc_cont)
                })
              })
            })
          ])
          (make-node :view/expr/symbol { :str :to })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-xc_then)
            })
          })
        ])
        (make-node :view/expr/flow [
          (make-node :view/sequence []) ; empty, so there's just one quad of indent
          (make-node :view/expr/keyword { :str "else" })
          (make-node :view/expr/symbol { :str :to })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-xc_else)
            })
          })
        ])
      ])
    })
    
    :expand
    (make-node :kernel/quote {
      :body
      (make-node :kernel/let {
        :bind 
        (make-node :kernel/bind :x_match-xc { :name "x" })

        :expr
        (make-node :kernel/unquote {
          :body
          (make-node :kernel/var {
            :ref (ref-node :match-xc_expr)
          })
        })
        
        :body
        (make-node :kernel/if {
          :test
          ; (make-node :core/and {
          ;            :left  ; is a cf node
            (make-node :core/equal {
              :left
              (make-node :core/type {
                :node
                (make-node :kernel/var {
                  :ref (ref-node :x_match-xc)
                })
              })
              
              :right
              (make-node :kernel/name { :value :cf/fraction })
            })

            ; :right  ; _does_ have a cont. attr
            ;            (make-node :core/has? {
            ;              :node 
            ;              (make-node :kernel/var {
            ;                :ref (ref-node :x_match-xc)
            ;              })
            ;          
            ;              :name
            ;              (make-node :kernel/name { :value :cont })
            ;            })
            ;          })
        
          :then
          (make-node :kernel/let {
            :bind 
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :match-xc_coeff)
              })
            })
            
            :expr
            (make-node :core/eval {
              :node
              (make-node :core/attr {
                :node 
                (make-node :kernel/var {
                  :ref (ref-node :x_match-xc)
                })
            
                :name
                (make-node :kernel/name { :value :coeff })
              })
            })

            :body
            (make-node :kernel/let {
              :bind 
              (make-node :kernel/unquote {
                :body
                (make-node :kernel/var {
                  :ref (ref-node :match-xc_cont)
                })
              })
            
              :expr
              (make-node :core/attr {
                :node 
                (make-node :kernel/var {
                  :ref (ref-node :x_match-xc)
                })
          
                :name
                (make-node :kernel/name { :value :cont })
              })

              :body
              (make-node :kernel/unquote {
                :body
                (make-node :kernel/var {
                  :ref (ref-node :match-xc_then)
                })
              })
            })
          })

          :else
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-xc_else)
            })
          })
        })
      })
    })
  })
    
  ; match-vc
  (make-node :grammar/mapNode {
    :doc 
    (make-node :grammar/doc { :str "Pattern-match for a fraction with a continuation and a specific coefficient" })
    
    :type
    (make-node :grammar/type :cf/match-vc)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :match-vc_expr {
        :name
        (make-node :grammar/name :cf/match-vc/expr)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-vc_coeff {
        :name
        (make-node :grammar/name :cf/match-vc/coeff)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-vc_cont {
        :name
        (make-node :grammar/name :cf/match-vc/cont)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/bind })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-vc_then {
        :name
        (make-node :grammar/name :cf/match-vc/then)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-vc_else {
        :name
        (make-node :grammar/name :cf/match-vc/else)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
    ])
    
    :display
    (make-node :kernel/quote {
      :body
      (make-node :view/section [
        (make-node :view/expr/flow [
          (make-node :view/expr/keyword { :str "match" })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-vc_expr)
            })
          })
        ])
        (make-node :view/expr/flow [
          (make-node :view/sequence []) ; empty, so there's just one quad of indent
          ; (make-node :view/expr/symbol { :str "|" })
          (make-node :view/expr/binary [
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :match-vc_coeff)
              })
            })
            (make-node :view/expr/symbol { :str "+" })
            (make-node :view/over {
              :top
              (make-node :kernel/int { :value 1 })
              
              :weight 1
              
              :bottom
              (make-node :kernel/unquote {
                :body
                (make-node :kernel/var {
                  :ref (ref-node :match-vc_cont)
                })
              })
            })
          ])
          (make-node :view/expr/symbol { :str :to })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-vc_then)
            })
          })
        ])
        (make-node :view/expr/flow [
          (make-node :view/sequence []) ; empty, so there's just one quad of indent
          (make-node :view/expr/keyword { :str "else" })
          (make-node :view/expr/symbol { :str :to })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-vc_else)
            })
          })
        ])
      ])
    })
    
    :expand
    (make-node :kernel/quote {
      :body
      (make-node :kernel/let {
        :bind 
        (make-node :kernel/bind :x_match-vc { :name "x" })

        :expr
        (make-node :kernel/unquote {
          :body
          (make-node :kernel/var {
            :ref (ref-node :match-vc_expr)
          })
        })
        
        :body
        (make-node :kernel/if {
          :test
          (make-node :core/and {
            :left  ; is a cf node
            (make-node :core/equal {
              :left
              (make-node :core/type {
                :node
                (make-node :kernel/var {
                  :ref (ref-node :x_match-vc)
                })
              })
              
              :right
              (make-node :kernel/name { :value :cf/fraction })
            })

            :right
            ; (make-node :core/and {
            ;               :left  ; _does_ have a cont. attr
            ;               (make-node :core/has? {
            ;                 :node 
            ;                 (make-node :kernel/var {
            ;                   :ref (ref-node :x_match-vc)
            ;                 })
            ;           
            ;                 :name
            ;                 (make-node :kernel/name { :value :cont })
            ;               })
            ;               
            ;               :right  ; coeff. matches the given expr
              (make-node :core/equal {
                :left
                (make-node :kernel/unquote {
                  :body
                  (make-node :kernel/var {
                    :ref (ref-node :match-vc_coeff)
                  })
                })
                
                :right
                (make-node :core/eval {
                  :node
                  (make-node :core/attr {
                    :node 
                    (make-node :kernel/var {
                      :ref (ref-node :x_match-vc)
                    })
            
                    :name
                    (make-node :kernel/name { :value :coeff })
                  })
                })
              })
            ; })
          })
          
          :then
          ; (make-node :kernel/let {
          ;   :bind 
          ;   (make-node :kernel/unquote {
          ;     :body
          ;     (make-node :kernel/var {
          ;       :ref (ref-node :match-vc_coeff)
          ;     })
          ;   })
          ;   
          ;   :expr
          ;   (make-node :core/eval {
          ;     :node
          ;     (make-node :core/attr {
          ;       :node 
          ;       (make-node :kernel/var {
          ;         :ref (ref-node :x_match-vc)
          ;       })
          ;   
          ;       :name
          ;       (make-node :kernel/name { :value :coeff })
          ;     })
          ;   })
          ; 
          ;   :body
            (make-node :kernel/let {
              :bind 
              (make-node :kernel/unquote {
                :body
                (make-node :kernel/var {
                  :ref (ref-node :match-vc_cont)
                })
              })
            
              :expr
              (make-node :core/attr {
                :node 
                (make-node :kernel/var {
                  :ref (ref-node :x_match-vc)
                })
          
                :name
                (make-node :kernel/name { :value :cont })
              })

              :body
              (make-node :kernel/unquote {
                :body
                (make-node :kernel/var {
                  :ref (ref-node :match-vc_then)
                })
              })
            })
          ; })

          :else
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-vc_else)
            })
          })
        })
      })
    })
  })
    
  ; ; coeff
  ; (make-node :grammar/mapNode {
  ;   :type
  ;   (make-node :grammar/type :cf/coeff)
  ;   
  ;   :supers 
  ;   (make-node :grammar/types [
  ;     (make-node :grammar/type :kernel/expr)
  ;   ])
  ;   
  ;   :attrs
  ;   (make-node :grammar/attrs [
  ;     (make-node :grammar/attr :coeff_expr {
  ;       :name
  ;       (make-node :grammar/name :cf/coeff/expr)
  ;       
  ;       :options
  ;       (make-node :grammar/options [
  ;         (make-node :grammar/node { :type :kernel/expr })
  ;       ])
  ;       
  ;       :optional false
  ;     }) 
  ;   ])
  ;   
  ;   :display
  ;   (make-node :kernel/quote {
  ;     :body
  ;     (make-node :view/expr/juxt [
  ;       (make-node :view/expr/keyword { :str "coeff" })
  ;       (make-node :view/delimited {
  ;         :left "["
  ;         :right "]"
  ;         :content
  ;         (make-node :kernel/unquote {
  ;           :body
  ;           (make-node :kernel/var {
  ;            :ref (ref-node :coeff_expr) 
  ;           })
  ;         })
  ;       })
  ;     ])
  ;   })
  ;   
  ;   :expand
  ;   (make-node :kernel/quote {
  ;     :body
  ;     (make-node :core/attr {
  ;       :node
  ;       (make-node :kernel/unquote {
  ;         :body
  ;         (make-node :kernel/var {
  ;          :ref (ref-node :coeff_expr) 
  ;         })
  ;       })
  ;       
  ;       :name
  ;       (make-node :kernel/name { :value :coeff })
  ;     })
  ;   })
  ; })

  ; ; cont
  ; (make-node :grammar/mapNode {
  ;   :type
  ;   (make-node :grammar/type :cf/cont)
  ;   
  ;   :supers 
  ;   (make-node :grammar/types [
  ;     (make-node :grammar/type :kernel/expr)
  ;   ])
  ;   
  ;   :attrs
  ;   (make-node :grammar/attrs [
  ;     (make-node :grammar/attr :cont_expr {
  ;       :name
  ;       (make-node :grammar/name :cf/cont/expr)
  ;       
  ;       :options
  ;       (make-node :grammar/options [
  ;         (make-node :grammar/node { :type :kernel/expr })
  ;       ])
  ;       
  ;       :optional false
  ;     }) 
  ;   ])
  ;   
  ;   :display
  ;   (make-node :kernel/quote {
  ;     :body
  ;     (make-node :view/expr/juxt [
  ;       (make-node :view/expr/keyword { :str "cont" })
  ;       (make-node :view/delimited {
  ;         :left "["
  ;         :right "]"
  ;         :content
  ;         (make-node :kernel/unquote {
  ;           :body
  ;           (make-node :kernel/var {
  ;            :ref (ref-node :cont_expr) 
  ;           })
  ;         })
  ;       })
  ;     ])
  ;   })
  ;   
  ;   :expand
  ;   (make-node :kernel/quote {
  ;     :body
  ;     (make-node :core/attr {
  ;       :node
  ;       (make-node :kernel/unquote {
  ;         :body
  ;         (make-node :kernel/var {
  ;          :ref (ref-node :cont_expr) 
  ;         })
  ;       })
  ;       
  ;       :name
  ;       (make-node :kernel/name { :value :cont })
  ;     })
  ;   })
  ; })
  
  ; ratio
  (make-node :grammar/mapNode {
    :type
    (make-node :grammar/type :cf/ratio)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :ratio_expr {
        :name
        (make-node :grammar/name :cf/ratio/expr)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
    ])
    
    :display
    (make-node :kernel/quote {
      :body
      (make-node :view/expr/juxt [
        (make-node :view/expr/keyword { :str "ratio" })
        (make-node :view/delimited {
          :left "["
          :right "]"
          :content
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
             :ref (ref-node :ratio_expr) 
            })
          })
        })
      ])
    })
    
    :expand
    (make-node :kernel/quote {
      :body
      (make-node :core/where {
        :body
        (make-node :kernel/app {
          :expr
          (make-node :kernel/var {
            :ref (ref-node :r_ratio)
          })
          
          :args
          (make-node :kernel/args [
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {            
                :ref (ref-node :ratio_expr)
              })
            })
          ])
        })
        
        :vars
        (make-node :core/whereVars [
          (make-node :core/whereVar {
            :bind
            (make-node :kernel/bind :r_ratio { :name "r" })
            
            :expr
            (make-node :kernel/lambda :r_p_ratio {
              :params
              (make-node :kernel/params [
                (make-node :kernel/bind :c_ratio { :name "c" })
              ])
              
              :body
              (make-node :cf/match-xc {
                :expr
                (make-node :kernel/var {            
                  :ref (ref-node :c_ratio)
                })
                
                :coeff
                (make-node :kernel/bind :n_ratio { :name "n" })
                
                :cont
                (make-node :kernel/bind :d_ratio { :name "d" })
                
                :then
                (make-node :kernel/if {
                  :test
                  (make-node :core/equal {
                    :left
                    (make-node :kernel/var {            
                      :ref (ref-node :d_ratio)
                    })
                    
                    :right
                    (make-node :cf/inf)
                  })
                  
                  :then
                  (make-node :kernel/var {            
                    :ref (ref-node :n_ratio)
                  })
                  
                  :else
                  (make-node :core/plus {
                    :left
                    (make-node :kernel/var {            
                      :ref (ref-node :n_ratio)
                    })
                    
                    :right
                    (make-node :core/fraction {
                      :num
                      (make-node :kernel/int { :value 1 })
                      
                      :denom
                      (make-node :kernel/app {
                        :expr
                        (make-node :kernel/var {            
                          :ref (ref-node :r_p_ratio)
                        })
  
                        :args
                        (make-node :kernel/args [
                          (make-node :kernel/var {            
                            :ref (ref-node :d_ratio)
                          })
                        ])
                      })
                    })
                  })
                })
                
                :else
                (make-node :core/fail)
              })
            })
          })
        ])
      })
    })
  
    ; (make-node :kernel/quote {
    ;   :body
    ;   (make-node :kernel/let {
    ;     :bind
    ;     (make-node :kernel/bind :r_ratio {})
    ;     
    ;     :expr
    ;     (make-node :kernel/lambda :q_ratio {
    ;       :params
    ;       (make-node :kernel/params [
    ;         (make-node :kernel/bind :f_ratio {})
    ;       ])
    ;       
    ;       :body
    ;       ; TODO: use match-v/2
    ;       (make-node :kernel/if {
    ;         :test
    ;         (make-node :core/has? {
    ;           :node
    ;           (make-node :kernel/var {
    ;            :ref (ref-node :f_ratio) 
    ;           })
    ;           
    ;           :name
    ;           (make-node :kernel/name { :value :cont })
    ;         })
    ;           
    ;         ; (make-node :core/equal {
    ;         ;   :left
    ;         ;   (make-node :core/type {
    ;         ;     :node
    ;         ;     (make-node :kernel/var {
    ;         ;      :ref (ref-node :f_ratio) 
    ;         ;     })
    ;         ;   })
    ;         ;   
    ;         ;   :right
    ;         ;   (make-node :kernel/name { :value :cf/fraction })
    ;         ; })
    ;   
    ;         :then
    ;         (make-node :core/plus {
    ;           :left
    ;           (make-node :core/eval {
    ;             :node
    ;             (make-node :cf/coeff {
    ;               :expr
    ;               (make-node :kernel/var {
    ;                :ref (ref-node :f_ratio) 
    ;               })
    ;             })
    ;           })
    ;           
    ;           :right
    ;           (make-node :core/fraction {
    ;             :num
    ;             (make-node :kernel/int { :value 1 })
    ;         
    ;             :denom
    ;             (make-node :kernel/app {
    ;               :expr
    ;               (make-node :kernel/var {
    ;                 :ref (ref-node :q_ratio)
    ;               })
    ;               
    ;               :args
    ;               (make-node :kernel/args [
    ;                 (make-node :cf/cont {
    ;                   :expr
    ;                   (make-node :kernel/var {
    ;                    :ref (ref-node :f_ratio) 
    ;                   })
    ;                 })
    ;               ])
    ;             })
    ;           })
    ;         })
    ; 
    ;         :else
    ;         (make-node :core/eval {
    ;           :node
    ;           (make-node :cf/coeff {
    ;             :expr
    ;             (make-node :kernel/var {
    ;              :ref (ref-node :f_ratio) 
    ;             })
    ;           })
    ;         })
    ;       })
    ;     })
    ;   
    ;     :body
    ;     (make-node :kernel/app {
    ;       :expr
    ;       (make-node :kernel/var {
    ;         :ref (ref-node :r_ratio)
    ;       })
    ;       
    ;       :args
    ;       (make-node :kernel/args [
    ;         (make-node :kernel/unquote {
    ;           :body
    ;           (make-node :kernel/var {            
    ;             :ref (ref-node :ratio_expr)
    ;           })
    ;         })
    ;       ])
    ;     })
    ;   })
    ; })
  })
  
  ; match-xv
  (make-node :grammar/mapNode {
    :doc 
    (make-node :grammar/doc { :str "Pattern-match for a fraction with a continuation and a specific coefficient" })
    
    :type
    (make-node :grammar/type :cf/match-xv)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :match-xv_expr {
        :name
        (make-node :grammar/name :cf/match-xv/expr)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-xv_x {
        :name
        (make-node :grammar/name :cf/match-xv/x)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/bind })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-xv_v {
        :name
        (make-node :grammar/name :cf/match-xv/v)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-xv_then {
        :name
        (make-node :grammar/name :cf/match-xv/then)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-xv_else {
        :name
        (make-node :grammar/name :cf/match-xv/else)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
    ])
    
    :display
    (make-node :kernel/quote {
      :body
      (make-node :view/section [
        (make-node :view/expr/flow [
          (make-node :view/expr/keyword { :str "match" })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-xv_expr)
            })
          })
        ])
        (make-node :view/expr/flow [
          (make-node :view/sequence []) ; empty, so there's just one quad of indent
          ; (make-node :view/expr/symbol { :str "|" })
          (make-node :view/expr/binary [
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :match-xv_x)
              })
            })
            (make-node :view/expr/symbol { :str "+" })
            (make-node :view/over {
              :top
              (make-node :kernel/int { :value 1 })
              
              :weight 1
              
              :bottom
              (make-node :view/expr/binary [
                (make-node :kernel/unquote {
                  :body
                  (make-node :kernel/var {
                    :ref (ref-node :match-xv_v)
                  })
                })
                (make-node :view/expr/symbol { :str "+" })
                (make-node :view/expr/symbol { :str :circ })
              ])
            })
          ])
          (make-node :view/expr/symbol { :str :to })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-xv_then)
            })
          })
        ])
        (make-node :view/expr/flow [
          (make-node :view/sequence []) ; empty, so there's just one quad of indent
          (make-node :view/expr/keyword { :str "else" })
          (make-node :view/expr/symbol { :str :to })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-xv_else)
            })
          })
        ])
      ])
    })
    
    ; TODO:
    ; :expand
  })  
  
  ; match-xvxc
  (make-node :grammar/mapNode {
    :type
    (make-node :grammar/type :cf/match-xvxc)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :match-xvxc_expr {
        :name
        (make-node :grammar/name :cf/match-xvxc/expr)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-xvxc_x {
        :name
        (make-node :grammar/name :cf/match-xvxc/x)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/bind })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-xvxc_v {
        :name
        (make-node :grammar/name :cf/match-xvxc/v)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-xvxc_y {
        :name
        (make-node :grammar/name :cf/match-xvxc/y)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/bind })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-xvxc_c {
        :name
        (make-node :grammar/name :cf/match-xvxc/c)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-xvxc_then {
        :name
        (make-node :grammar/name :cf/match-xvxc/then)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-xvxc_else {
        :name
        (make-node :grammar/name :cf/match-xvxc/else)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
    ])
    
    :display
    (make-node :kernel/quote {
      :body
      (make-node :view/section [
        (make-node :view/expr/flow [
          (make-node :view/expr/keyword { :str "match" })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-xvxc_expr)
            })
          })
        ])
        (make-node :view/expr/flow [
          (make-node :view/sequence []) ; empty, so there's just one quad of indent
          ; (make-node :view/expr/symbol { :str "|" })
          (make-node :view/expr/binary [
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :match-xvxc_x)
              })
            })
            (make-node :view/expr/symbol { :str "+" })
            (make-node :view/over {
              :top
              (make-node :kernel/int { :value 1 })
              
              :weight 1
              
              :bottom
              (make-node :view/expr/binary [
                (make-node :kernel/unquote {
                  :body
                  (make-node :kernel/var {
                    :ref (ref-node :match-xvxc_v)
                  })
                })
                (make-node :view/expr/symbol { :str "+" })
                (make-node :view/over {
                  :top
                  (make-node :kernel/int { :value 1 })
            
                  :weight 1
            
                  :bottom
                  (make-node :view/expr/binary [
                    (make-node :kernel/unquote {
                      :body
                      (make-node :kernel/var {
                        :ref (ref-node :match-xvxc_y)
                      })
                    })
                    (make-node :view/expr/symbol { :str "+" })
                    (make-node :view/over {
                      :top
                      (make-node :kernel/int { :value 1 })
              
                      :weight 1
              
                      :bottom
                      (make-node :view/expr/binary [
                        (make-node :kernel/unquote {
                          :body
                          (make-node :kernel/var {
                            :ref (ref-node :match-xvxc_c)
                          })
                        })
                      ])
                    })
                  ])
                })
              ])
            })
          ])
          (make-node :view/expr/symbol { :str :to })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-xvxc_then)
            })
          })
        ])
        (make-node :view/expr/flow [
          (make-node :view/sequence []) ; empty, so there's just one quad of indent
          (make-node :view/expr/keyword { :str "else" })
          (make-node :view/expr/symbol { :str :to })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-xvxc_else)
            })
          })
        ])
      ])
    })
    
    ; TODO:
    ; :expand
  })  
  
  ; match-xxc
  (make-node :grammar/mapNode {
    :type
    (make-node :grammar/type :cf/match-xxc)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :match-xxc_expr {
        :name
        (make-node :grammar/name :cf/match-xxc/expr)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-xxc_x {
        :name
        (make-node :grammar/name :cf/match-xxc/x)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/bind })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-xxc_y {
        :name
        (make-node :grammar/name :cf/match-xxc/y)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/bind })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-xxc_c {
        :name
        (make-node :grammar/name :cf/match-xxc/c)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-xxc_then {
        :name
        (make-node :grammar/name :cf/match-xxc/then)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match-xxc_else {
        :name
        (make-node :grammar/name :cf/match-xxc/else)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :kernel/expr })
        ])
        
        :optional false
      }) 
    ])
    
    :display
    (make-node :kernel/quote {
      :body
      (make-node :view/section [
        (make-node :view/expr/flow [
          (make-node :view/expr/keyword { :str "match" })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-xxc_expr)
            })
          })
        ])
        (make-node :view/expr/flow [
          (make-node :view/sequence []) ; empty, so there's just one quad of indent
          ; (make-node :view/expr/symbol { :str "|" })
          (make-node :view/expr/binary [
            (make-node :kernel/unquote {
              :body
              (make-node :kernel/var {
                :ref (ref-node :match-xxc_x)
              })
            })
            (make-node :view/expr/symbol { :str "+" })
            (make-node :view/over {
              :top
              (make-node :kernel/int { :value 1 })
              
              :weight 1
              
              :bottom
              (make-node :view/expr/binary [
                (make-node :kernel/unquote {
                  :body
                  (make-node :kernel/var {
                    :ref (ref-node :match-xxc_y)
                  })
                })
                (make-node :view/expr/symbol { :str "+" })
                (make-node :view/over {
                  :top
                  (make-node :kernel/int { :value 1 })
            
                  :weight 1
            
                  :bottom
                  (make-node :view/expr/binary [
                    (make-node :kernel/unquote {
                      :body
                      (make-node :kernel/var {
                        :ref (ref-node :match-xxc_c)
                      })
                    })
                  ])
                })
              ])
            })
          ])
          (make-node :view/expr/symbol { :str :to })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-xxc_then)
            })
          })
        ])
        (make-node :view/expr/flow [
          (make-node :view/sequence []) ; empty, so there's just one quad of indent
          (make-node :view/expr/keyword { :str "else" })
          (make-node :view/expr/symbol { :str :to })
          (make-node :kernel/unquote {
            :body
            (make-node :kernel/var {
              :ref (ref-node :match-xxc_else)
            })
          })
        ])
      ])
    })
    
    ; TODO:
    ; :expand
  })  
  
])