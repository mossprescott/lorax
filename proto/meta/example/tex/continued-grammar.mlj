(use 'meta.core)  ; ignored by load-nodes, but should make this file legal Clojure

(make-node :grammar/language [

  ; inf
  (make-node :grammar/mapNode {
    :doc 
    (make-node :grammar/doc { :str "'nil' fraction value, mathematically equal to infinity." })
    
    :type
    (make-node :grammar/type :cf/inf)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :clojure/kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [])
    
    :display
    (make-node :clojure/kernel/quote {
      :body
      (make-node :view/expr/symbol { :str :circ })
    })
    
    :expand
    (make-node :clojure/kernel/quote {
      :body
      (make-node :clojure/core/makeNode {
        :type
        (make-node :clojure/kernel/name { :value :cf/inf })
        
        :content
        (make-node :clojure/core/noAttrs)
      })
    })
  })
  
  ; fraction
  (make-node :grammar/mapNode {
    :doc 
    (make-node :grammar/doc { :str "Continued fraction constructor, with coefficient (an int at runtime) and continuation (a cont. fraction, or inf)." })
    
    :type
    (make-node :grammar/type :cf/fraction)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :clojure/kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :cf_coeff {
        :name
        (make-node :grammar/name :cf/fraction/coeff)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :clojure/kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :cf_cont {
        :name
        (make-node :grammar/name :cf/fraction/cont)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :clojure/kernel/expr })
        ])
        
        :optional false
      }) 
    ])
    
    :display
    (make-node :clojure/kernel/quote {
      :body
      (make-node :view/expr/relation [
        (make-node :clojure/kernel/unquote {
          :body
          (make-node :clojure/kernel/var {
           :ref (ref-node :cf_coeff) ; HACK
          })
        })
        (make-node :view/expr/symbol { :str "+" })
        ; Note: need a conditional to render the nullary continuation specially:
        (make-node :clojure/kernel/unquote {
          :body
          (make-node :clojure/kernel/if {
            :test
            ; (make-node :clojure/core/missing? {
            ;   :node
            ;   (make-node :clojure/kernel/var {
            ;     :ref (ref-node :cf_cont)
            ;   })
            ; })
            (make-node :clojure/core/equal {
              :left
              (make-node :clojure/kernel/var {
                :ref (ref-node :cf_cont)
              })
              
              :right
              ; (make-node :clojure/kernel/quote {
              ;   :body
                (make-node :cf/inf)
              ; })
            })
            
            :then
            (make-node :clojure/kernel/var {
             :ref (ref-node :cf_cont) 
            })
            ; (make-node :clojure/kernel/quote {
            ;   :body
            ;   (make-node :view/expr/symbol { :str :circ })
            ; })
            
            :else
            (make-node :clojure/kernel/quote {
              :body
              (make-node :view/over {
                :top
                (make-node :clojure/kernel/int { :value 1 })
                    
                :weight 1
                  
                :bottom
                (make-node :clojure/kernel/unquote {
                  :body
                  (make-node :clojure/kernel/var {
                   :ref (ref-node :cf_cont) 
                  })
                })
              })
            })
          })
        })
      ])
    })
    
    :expand  ; evaluates the sub-components and constructs a run-time node!
    (make-node :clojure/kernel/quote {
      :body
      (make-node :clojure/core/makeNode {
        :type
        (make-node :clojure/kernel/name { :value :cf/fraction })
        
        :content
        (make-node :clojure/core/nodeAttrs [
          (make-node :clojure/core/nodeAttr {
            :name
            (make-node :clojure/kernel/name { :value :coeff })
            
            :value
            (make-node :clojure/core/unread {
              :node
              (make-node :clojure/kernel/unquote {
                :body
                (make-node :clojure/kernel/var {
                 :ref (ref-node :cf_coeff) 
                })
              })
            })
          })
          (make-node :clojure/core/nodeAttr {
            :name
            (make-node :clojure/kernel/name { :value :cont })
            
            :value
            (make-node :clojure/core/unread {
              :node
              (make-node :clojure/kernel/unquote {
                :body
                (make-node :clojure/kernel/var {
                 :ref (ref-node :cf_cont) 
                })
              })
            })
          })
        ])
      })
    })
    
    ; (make-node :clojure/kernel/if {
    ;   :test
    ;   (make-node :clojure/core/missing? {
    ;     :node
    ;     (make-node :clojure/kernel/var {
    ;      :ref (ref-node :cf_cont) 
    ;     })
    ;   })
    ;   
    ;   :then
    ;   (make-node :clojure/kernel/quote {
    ;     :body
    ;     ; Tricky! double-quotation doesn't work because I reduce the node under 
    ;     ; the quote. There's probably an answer (a form of quotation that 
    ;     ; blocks reduction?), but for now a hack.
    ;     ; TODO: at least add some simpler syntax for doing this.
    ;     (make-node :clojure/kernel/app {
    ;       :expr
    ;       (make-node :clojure/kernel/extern { :name "meta.core/make-node"})
    ;     
    ;       :args 
    ;       (make-node :clojure/kernel/args [
    ;         (make-node :clojure/kernel/name { :value :cf/fraction })
    ;         (make-node :clojure/kernel/app {
    ;           :expr
    ;           (make-node :clojure/kernel/extern { :name "hash-map"})
    ;       
    ;           :args 
    ;           (make-node :clojure/kernel/args [
    ;             (make-node :clojure/kernel/name { :value :coeff })
    ;   
    ;             ; Tricky: the value of the attribute may need to be unread back into a node:
    ;             (make-node :clojure/kernel/app {
    ;               :expr
    ;               (make-node :clojure/kernel/extern { :name "meta.clojure.kernel/unread"})
    ;       
    ;               :args 
    ;               (make-node :clojure/kernel/args [
    ;                 (make-node :clojure/kernel/unquote {
    ;                   :body
    ;                   (make-node :clojure/kernel/var {
    ;                    :ref (ref-node :cf_coeff) 
    ;                   })
    ;                 })
    ;               ])
    ;             })
    ;           ])
    ;         })
    ;       ])
    ;     })
    ;   })
    ;           
    ;   :else
    ;   (make-node :clojure/kernel/quote {
    ;     :body
    ;     ; Tricky! double-quotation doesn't work because I reduce the node under 
    ;     ; the quote. There's probably an answer (a form of quotation that 
    ;     ; blocks reduction?), but for now a hack.
    ;     ; TODO: at least add some simpler syntax for doing this.
    ;     (make-node :clojure/kernel/app {
    ;       :expr
    ;       (make-node :clojure/kernel/extern { :name "meta.core/make-node"})
    ;     
    ;       :args 
    ;       (make-node :clojure/kernel/args [
    ;         (make-node :clojure/kernel/name { :value :cf/fraction })
    ;         (make-node :clojure/kernel/app {
    ;           :expr
    ;           (make-node :clojure/kernel/extern { :name "hash-map"})
    ;             
    ;           :args 
    ;           (make-node :clojure/kernel/args [
    ;             (make-node :clojure/kernel/name { :value :coeff })
    ;   
    ;             ; Tricky: the value of the attribute may need to be unread back into a node:
    ;             (make-node :clojure/kernel/app {
    ;               :expr
    ;               (make-node :clojure/kernel/extern { :name "meta.clojure.kernel/unread"})
    ;     
    ;               :args 
    ;               (make-node :clojure/kernel/args [
    ;                 (make-node :clojure/kernel/unquote {
    ;                   :body
    ;                   (make-node :clojure/kernel/var {
    ;                    :ref (ref-node :cf_coeff) 
    ;                   })
    ;                 })
    ;               ])
    ;             })
    ;   
    ;             ; TODO: handle missing :cont
    ;             (make-node :clojure/kernel/name { :value :cont })
    ;   
    ;             ; Tricky: the value of the attribute may need to be unread back into a node:
    ;             (make-node :clojure/kernel/app {
    ;               :expr
    ;               (make-node :clojure/kernel/extern { :name "meta.clojure.kernel/unread"})
    ;     
    ;               :args 
    ;               (make-node :clojure/kernel/args [
    ;                 (make-node :clojure/kernel/unquote {
    ;                   :body
    ;                   (make-node :clojure/kernel/var {
    ;                    :ref (ref-node :cf_cont) 
    ;                   })
    ;                 })
    ;               ])
    ;             })
    ;           ])
    ;         })
    ;       ])
    ;     })
    ;   })
    
      ; (make-node :clojure/kernel/quote {
      ;   :body
      ;   (make-node :clojure/kernel/nil)
      ;   ; (make-node :clojure/core/continuedFraction {
      ;   ;   :coeff
      ;   ;   (make-node :clojure/kernel/int { :value 2 })
      ;   ; ;   (make-node :clojure/kernel/unquote {
      ;   ; ;     :body
      ;   ; ;     (make-node :clojure/kernel/unquote {
      ;   ; ;       :body
      ;   ; ;       (make-node :clojure/kernel/var {
      ;   ; ;        :ref (ref-node :cf_coeff) 
      ;   ; ;       })
      ;   ; ;     })
      ;   ; ;   })
      ;   ; ; 
      ;   ;   :cont
      ;   ;   (make-node :clojure/kernel/int { :value 3 })
      ;   ; ;   (make-node :clojure/kernel/unquote {
      ;   ; ;     :body
      ;   ; ;     (make-node :clojure/kernel/unquote {
      ;   ; ;       :body
      ;   ; ;       (make-node :clojure/kernel/var {
      ;   ; ;        :ref (ref-node :cf_cont) 
      ;   ; ;       })
      ;   ; ;     })
      ;   ; ;   })
      ;   ; })
      ; })
  })

  ; ; match1
  ; (make-node :grammar/mapNode {
  ;   :doc 
  ;   (make-node :grammar/doc { :str "Pattern-match for a fraction with no continuation (i.e. representing an integer)" })
  ;   
  ;   :type
  ;   (make-node :grammar/type :cf/match1)
  ;   
  ;   :supers 
  ;   (make-node :grammar/types [
  ;     (make-node :grammar/type :clojure/kernel/expr)
  ;   ])
  ;   
  ;   :attrs
  ;   (make-node :grammar/attrs [
  ;     (make-node :grammar/attr :match1_expr {
  ;       :name
  ;       (make-node :grammar/name :cf/match1/expr)
  ;       
  ;       :options
  ;       (make-node :grammar/options [
  ;         (make-node :grammar/node { :type :clojure/kernel/expr })
  ;       ])
  ;       
  ;       :optional false
  ;     }) 
  ;     (make-node :grammar/attr :match1_coeff {
  ;       :name
  ;       (make-node :grammar/name :cf/match1/coeff)
  ;       
  ;       :options
  ;       (make-node :grammar/options [
  ;         (make-node :grammar/node { :type :clojure/kernel/bind })
  ;       ])
  ;       
  ;       :optional false
  ;     }) 
  ;     (make-node :grammar/attr :match1_then {
  ;       :name
  ;       (make-node :grammar/name :cf/match1/then)
  ;       
  ;       :options
  ;       (make-node :grammar/options [
  ;         (make-node :grammar/node { :type :clojure/kernel/expr })
  ;       ])
  ;       
  ;       :optional false
  ;     }) 
  ;     (make-node :grammar/attr :match1_else {
  ;       :name
  ;       (make-node :grammar/name :cf/match1/else)
  ;       
  ;       :options
  ;       (make-node :grammar/options [
  ;         (make-node :grammar/node { :type :clojure/kernel/expr })
  ;       ])
  ;       
  ;       :optional false
  ;     }) 
  ;   ])
  ;   
  ;   :display
  ;   (make-node :clojure/kernel/quote {
  ;     :body
  ;     (make-node :view/section [
  ;       (make-node :view/expr/flow [
  ;         (make-node :view/expr/keyword { :str "match" })
  ;         (make-node :clojure/kernel/unquote {
  ;           :body
  ;           (make-node :clojure/kernel/var {
  ;             :ref (ref-node :match1_expr)
  ;           })
  ;         })
  ;         (make-node :view/expr/symbol { :str "|" })
  ;         (make-node :view/expr/binary [
  ;           (make-node :clojure/kernel/unquote {
  ;             :body
  ;             (make-node :clojure/kernel/var {
  ;               :ref (ref-node :match1_coeff)
  ;             })
  ;           })
  ;           (make-node :view/expr/symbol { :str "+" })
  ;           (make-node :view/expr/symbol { :str :circ })
  ;         ])
  ;         (make-node :view/expr/symbol { :str :to })
  ;         (make-node :clojure/kernel/unquote {
  ;           :body
  ;           (make-node :clojure/kernel/var {
  ;             :ref (ref-node :match1_then)
  ;           })
  ;         })
  ;       ])        
  ;       (make-node :view/expr/flow [
  ;         (make-node :view/sequence []) ; empty, so there's just one quad of indent
  ;         (make-node :view/expr/keyword { :str "else" })
  ;         (make-node :clojure/kernel/unquote {
  ;           :body
  ;           (make-node :clojure/kernel/var {
  ;             :ref (ref-node :match1_else)
  ;           })
  ;         })
  ;       ])
  ;     ])
  ;   })
  ;   
  ;   :expand
  ;   (make-node :clojure/kernel/quote {
  ;     :body
  ;     (make-node :clojure/kernel/let {
  ;       :bind 
  ;       (make-node :clojure/kernel/bind :x_match1 { :name "x" })
  ; 
  ;       :expr
  ;       (make-node :clojure/kernel/unquote {
  ;         :body
  ;         (make-node :clojure/kernel/var {
  ;           :ref (ref-node :match1_expr)
  ;         })
  ;       })
  ;       
  ;       :body
  ;       (make-node :clojure/kernel/if {
  ;         :test
  ;         (make-node :clojure/core/and {
  ;           :left  ; is a cf node
  ;           (make-node :clojure/core/equal {
  ;             :left
  ;             (make-node :clojure/core/type {
  ;               :node
  ;               (make-node :clojure/kernel/var {
  ;                 :ref (ref-node :x_match1)
  ;               })
  ;             })
  ;             
  ;             :right
  ;             (make-node :clojure/kernel/name { :value :cf/fraction })
  ;           })
  ; 
  ;           :right  ; does _not_ have a cont. attr
  ;           (make-node :clojure/core/not {
  ;             :expr
  ;             (make-node :clojure/core/has? {
  ;               :node 
  ;               (make-node :clojure/kernel/var {
  ;                 :ref (ref-node :x_match1)
  ;               })
  ;           
  ;               :name
  ;               (make-node :clojure/kernel/name { :value :cont })
  ;             })
  ;           })
  ;         })
  ;       
  ;         :then
  ;         (make-node :clojure/kernel/let {
  ;           :bind 
  ;           (make-node :clojure/kernel/unquote {
  ;             :body
  ;             (make-node :clojure/kernel/var {
  ;               :ref (ref-node :match1_coeff)
  ;             })
  ;           })
  ;           
  ;           :expr
  ;           (make-node :clojure/core/eval {
  ;             :node
  ;             (make-node :clojure/core/attr {
  ;               :node 
  ;               (make-node :clojure/kernel/var {
  ;                 :ref (ref-node :x_match1)
  ;               })
  ;           
  ;               :name
  ;               (make-node :clojure/kernel/name { :value :coeff })
  ;             })
  ;           })
  ; 
  ;           :body
  ;           (make-node :clojure/kernel/unquote {
  ;             :body
  ;             (make-node :clojure/kernel/var {
  ;               :ref (ref-node :match1_then)
  ;             })
  ;           })
  ;         })
  ;       
  ;         :else
  ;         (make-node :clojure/kernel/unquote {
  ;           :body
  ;           (make-node :clojure/kernel/var {
  ;             :ref (ref-node :match1_else)
  ;           })
  ;         })
  ;       })
  ;     })
  ;   })
  ; })

  ; match2
  (make-node :grammar/mapNode {
    :doc 
    (make-node :grammar/doc { :str "Pattern-match for a fraction with arbitrary coefficient and continuation." })
    
    :type
    (make-node :grammar/type :cf/match2)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :clojure/kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :match2_expr {
        :name
        (make-node :grammar/name :cf/match2/expr)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :clojure/kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match2_coeff {
        :name
        (make-node :grammar/name :cf/match2/coeff)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :clojure/kernel/bind })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match2_cont {
        :name
        (make-node :grammar/name :cf/match2/cont)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :clojure/kernel/bind })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match2_then {
        :name
        (make-node :grammar/name :cf/match2/then)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :clojure/kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match2_else {
        :name
        (make-node :grammar/name :cf/match2/else)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :clojure/kernel/expr })
        ])
        
        :optional false
      }) 
    ])
    
    :display
    (make-node :clojure/kernel/quote {
      :body
      (make-node :view/section [
        (make-node :view/expr/flow [
          (make-node :view/expr/keyword { :str "match" })
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :match2_expr)
            })
          })
        ])
        (make-node :view/expr/flow [
          (make-node :view/sequence []) ; empty, so there's just one quad of indent
          ; (make-node :view/expr/symbol { :str "|" })
          (make-node :view/expr/binary [
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :match2_coeff)
              })
            })
            (make-node :view/expr/symbol { :str "+" })
            (make-node :view/over {
              :top
              (make-node :clojure/kernel/int { :value 1 })
              
              :weight 1
              
              :bottom
              (make-node :clojure/kernel/unquote {
                :body
                (make-node :clojure/kernel/var {
                  :ref (ref-node :match2_cont)
                })
              })
            })
          ])
          (make-node :view/expr/symbol { :str :to })
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :match2_then)
            })
          })
        ])
        (make-node :view/expr/flow [
          (make-node :view/sequence []) ; empty, so there's just one quad of indent
          (make-node :view/expr/keyword { :str "else" })
          (make-node :view/expr/symbol { :str :to })
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :match2_else)
            })
          })
        ])
      ])
    })
    
    :expand
    (make-node :clojure/kernel/quote {
      :body
      (make-node :clojure/kernel/let {
        :bind 
        (make-node :clojure/kernel/bind :x_match2 { :name "x" })

        :expr
        (make-node :clojure/kernel/unquote {
          :body
          (make-node :clojure/kernel/var {
            :ref (ref-node :match2_expr)
          })
        })
        
        :body
        (make-node :clojure/kernel/if {
          :test
          (make-node :clojure/core/and {
            :left  ; is a cf node
            (make-node :clojure/core/equal {
              :left
              (make-node :clojure/core/type {
                :node
                (make-node :clojure/kernel/var {
                  :ref (ref-node :x_match2)
                })
              })
              
              :right
              (make-node :clojure/kernel/name { :value :cf/fraction })
            })

            :right  ; _does_ have a cont. attr
            (make-node :clojure/core/has? {
              :node 
              (make-node :clojure/kernel/var {
                :ref (ref-node :x_match2)
              })
          
              :name
              (make-node :clojure/kernel/name { :value :cont })
            })
          })
        
          :then
          (make-node :clojure/kernel/let {
            :bind 
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :match2_coeff)
              })
            })
            
            :expr
            (make-node :clojure/core/eval {
              :node
              (make-node :clojure/core/attr {
                :node 
                (make-node :clojure/kernel/var {
                  :ref (ref-node :x_match2)
                })
            
                :name
                (make-node :clojure/kernel/name { :value :coeff })
              })
            })

            :body
            (make-node :clojure/kernel/let {
              :bind 
              (make-node :clojure/kernel/unquote {
                :body
                (make-node :clojure/kernel/var {
                  :ref (ref-node :match2_cont)
                })
              })
            
              :expr
              (make-node :clojure/core/attr {
                :node 
                (make-node :clojure/kernel/var {
                  :ref (ref-node :x_match2)
                })
          
                :name
                (make-node :clojure/kernel/name { :value :cont })
              })

              :body
              (make-node :clojure/kernel/unquote {
                :body
                (make-node :clojure/kernel/var {
                  :ref (ref-node :match2_then)
                })
              })
            })
          })

          :else
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :match2_else)
            })
          })
        })
      })
    })
  })
    
  ; match3
  (make-node :grammar/mapNode {
    :doc 
    (make-node :grammar/doc { :str "Pattern-match for a fraction with a continuation and a specific coefficient" })
    
    :type
    (make-node :grammar/type :cf/match3)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :clojure/kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :match3_expr {
        :name
        (make-node :grammar/name :cf/match3/expr)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :clojure/kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match3_coeff {
        :name
        (make-node :grammar/name :cf/match3/coeff)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :clojure/kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match3_cont {
        :name
        (make-node :grammar/name :cf/match3/cont)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :clojure/kernel/bind })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match3_then {
        :name
        (make-node :grammar/name :cf/match3/then)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :clojure/kernel/expr })
        ])
        
        :optional false
      }) 
      (make-node :grammar/attr :match3_else {
        :name
        (make-node :grammar/name :cf/match3/else)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :clojure/kernel/expr })
        ])
        
        :optional false
      }) 
    ])
    
    :display
    (make-node :clojure/kernel/quote {
      :body
      (make-node :view/section [
        (make-node :view/expr/flow [
          (make-node :view/expr/keyword { :str "match" })
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :match3_expr)
            })
          })
        ])
        (make-node :view/expr/flow [
          (make-node :view/sequence []) ; empty, so there's just one quad of indent
          ; (make-node :view/expr/symbol { :str "|" })
          (make-node :view/expr/binary [
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {
                :ref (ref-node :match3_coeff)
              })
            })
            (make-node :view/expr/symbol { :str "+" })
            (make-node :view/over {
              :top
              (make-node :clojure/kernel/int { :value 1 })
              
              :weight 1
              
              :bottom
              (make-node :clojure/kernel/unquote {
                :body
                (make-node :clojure/kernel/var {
                  :ref (ref-node :match3_cont)
                })
              })
            })
          ])
          (make-node :view/expr/symbol { :str :to })
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :match3_then)
            })
          })
        ])
        (make-node :view/expr/flow [
          (make-node :view/sequence []) ; empty, so there's just one quad of indent
          (make-node :view/expr/keyword { :str "else" })
          (make-node :view/expr/symbol { :str :to })
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :match3_else)
            })
          })
        ])
      ])
    })
    
    :expand
    (make-node :clojure/kernel/quote {
      :body
      (make-node :clojure/kernel/let {
        :bind 
        (make-node :clojure/kernel/bind :x_match3 { :name "x" })

        :expr
        (make-node :clojure/kernel/unquote {
          :body
          (make-node :clojure/kernel/var {
            :ref (ref-node :match3_expr)
          })
        })
        
        :body
        (make-node :clojure/kernel/if {
          :test
          (make-node :clojure/core/and {
            :left  ; is a cf node
            (make-node :clojure/core/equal {
              :left
              (make-node :clojure/core/type {
                :node
                (make-node :clojure/kernel/var {
                  :ref (ref-node :x_match3)
                })
              })
              
              :right
              (make-node :clojure/kernel/name { :value :cf/fraction })
            })

            :right
            (make-node :clojure/core/and {
              :left  ; _does_ have a cont. attr
              (make-node :clojure/core/has? {
                :node 
                (make-node :clojure/kernel/var {
                  :ref (ref-node :x_match3)
                })
          
                :name
                (make-node :clojure/kernel/name { :value :cont })
              })
              
              :right  ; coeff. matches the given expr
              (make-node :clojure/core/equal {
                :left
                (make-node :clojure/kernel/unquote {
                  :body
                  (make-node :clojure/kernel/var {
                    :ref (ref-node :match3_coeff)
                  })
                })
                
                :right
                (make-node :clojure/core/eval {
                  :node
                  (make-node :clojure/core/attr {
                    :node 
                    (make-node :clojure/kernel/var {
                      :ref (ref-node :x_match3)
                    })
            
                    :name
                    (make-node :clojure/kernel/name { :value :coeff })
                  })
                })
              })
            })
          })
          
          :then
          ; (make-node :clojure/kernel/let {
          ;   :bind 
          ;   (make-node :clojure/kernel/unquote {
          ;     :body
          ;     (make-node :clojure/kernel/var {
          ;       :ref (ref-node :match3_coeff)
          ;     })
          ;   })
          ;   
          ;   :expr
          ;   (make-node :clojure/core/eval {
          ;     :node
          ;     (make-node :clojure/core/attr {
          ;       :node 
          ;       (make-node :clojure/kernel/var {
          ;         :ref (ref-node :x_match3)
          ;       })
          ;   
          ;       :name
          ;       (make-node :clojure/kernel/name { :value :coeff })
          ;     })
          ;   })
          ; 
          ;   :body
            (make-node :clojure/kernel/let {
              :bind 
              (make-node :clojure/kernel/unquote {
                :body
                (make-node :clojure/kernel/var {
                  :ref (ref-node :match3_cont)
                })
              })
            
              :expr
              (make-node :clojure/core/attr {
                :node 
                (make-node :clojure/kernel/var {
                  :ref (ref-node :x_match3)
                })
          
                :name
                (make-node :clojure/kernel/name { :value :cont })
              })

              :body
              (make-node :clojure/kernel/unquote {
                :body
                (make-node :clojure/kernel/var {
                  :ref (ref-node :match3_then)
                })
              })
            })
          ; })

          :else
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
              :ref (ref-node :match3_else)
            })
          })
        })
      })
    })
  })
    
  ; ; coeff
  ; (make-node :grammar/mapNode {
  ;   :type
  ;   (make-node :grammar/type :cf/coeff)
  ;   
  ;   :supers 
  ;   (make-node :grammar/types [
  ;     (make-node :grammar/type :clojure/kernel/expr)
  ;   ])
  ;   
  ;   :attrs
  ;   (make-node :grammar/attrs [
  ;     (make-node :grammar/attr :coeff_expr {
  ;       :name
  ;       (make-node :grammar/name :cf/coeff/expr)
  ;       
  ;       :options
  ;       (make-node :grammar/options [
  ;         (make-node :grammar/node { :type :clojure/kernel/expr })
  ;       ])
  ;       
  ;       :optional false
  ;     }) 
  ;   ])
  ;   
  ;   :display
  ;   (make-node :clojure/kernel/quote {
  ;     :body
  ;     (make-node :view/expr/juxt [
  ;       (make-node :view/expr/keyword { :str "coeff" })
  ;       (make-node :view/delimited {
  ;         :left "["
  ;         :right "]"
  ;         :content
  ;         (make-node :clojure/kernel/unquote {
  ;           :body
  ;           (make-node :clojure/kernel/var {
  ;            :ref (ref-node :coeff_expr) 
  ;           })
  ;         })
  ;       })
  ;     ])
  ;   })
  ;   
  ;   :expand
  ;   (make-node :clojure/kernel/quote {
  ;     :body
  ;     (make-node :clojure/core/attr {
  ;       :node
  ;       (make-node :clojure/kernel/unquote {
  ;         :body
  ;         (make-node :clojure/kernel/var {
  ;          :ref (ref-node :coeff_expr) 
  ;         })
  ;       })
  ;       
  ;       :name
  ;       (make-node :clojure/kernel/name { :value :coeff })
  ;     })
  ;   })
  ; })

  ; ; cont
  ; (make-node :grammar/mapNode {
  ;   :type
  ;   (make-node :grammar/type :cf/cont)
  ;   
  ;   :supers 
  ;   (make-node :grammar/types [
  ;     (make-node :grammar/type :clojure/kernel/expr)
  ;   ])
  ;   
  ;   :attrs
  ;   (make-node :grammar/attrs [
  ;     (make-node :grammar/attr :cont_expr {
  ;       :name
  ;       (make-node :grammar/name :cf/cont/expr)
  ;       
  ;       :options
  ;       (make-node :grammar/options [
  ;         (make-node :grammar/node { :type :clojure/kernel/expr })
  ;       ])
  ;       
  ;       :optional false
  ;     }) 
  ;   ])
  ;   
  ;   :display
  ;   (make-node :clojure/kernel/quote {
  ;     :body
  ;     (make-node :view/expr/juxt [
  ;       (make-node :view/expr/keyword { :str "cont" })
  ;       (make-node :view/delimited {
  ;         :left "["
  ;         :right "]"
  ;         :content
  ;         (make-node :clojure/kernel/unquote {
  ;           :body
  ;           (make-node :clojure/kernel/var {
  ;            :ref (ref-node :cont_expr) 
  ;           })
  ;         })
  ;       })
  ;     ])
  ;   })
  ;   
  ;   :expand
  ;   (make-node :clojure/kernel/quote {
  ;     :body
  ;     (make-node :clojure/core/attr {
  ;       :node
  ;       (make-node :clojure/kernel/unquote {
  ;         :body
  ;         (make-node :clojure/kernel/var {
  ;          :ref (ref-node :cont_expr) 
  ;         })
  ;       })
  ;       
  ;       :name
  ;       (make-node :clojure/kernel/name { :value :cont })
  ;     })
  ;   })
  ; })
  
  ; ratio
  (make-node :grammar/mapNode {
    :type
    (make-node :grammar/type :cf/ratio)
    
    :supers 
    (make-node :grammar/types [
      (make-node :grammar/type :clojure/kernel/expr)
    ])
    
    :attrs
    (make-node :grammar/attrs [
      (make-node :grammar/attr :ratio_expr {
        :name
        (make-node :grammar/name :cf/ratio/expr)
        
        :options
        (make-node :grammar/options [
          (make-node :grammar/node { :type :clojure/kernel/expr })
        ])
        
        :optional false
      }) 
    ])
    
    :display
    (make-node :clojure/kernel/quote {
      :body
      (make-node :view/expr/juxt [
        (make-node :view/expr/keyword { :str "ratio" })
        (make-node :view/delimited {
          :left "["
          :right "]"
          :content
          (make-node :clojure/kernel/unquote {
            :body
            (make-node :clojure/kernel/var {
             :ref (ref-node :ratio_expr) 
            })
          })
        })
      ])
    })
    
    :expand
    (make-node :clojure/kernel/quote {
      :body
      (make-node :clojure/core/where {
        :body
        (make-node :clojure/kernel/app {
          :expr
          (make-node :clojure/kernel/var {
            :ref (ref-node :r_ratio)
          })
          
          :args
          (make-node :clojure/kernel/args [
            (make-node :clojure/kernel/unquote {
              :body
              (make-node :clojure/kernel/var {            
                :ref (ref-node :ratio_expr)
              })
            })
          ])
        })
        
        :vars
        (make-node :clojure/core/whereVars [
          (make-node :clojure/core/whereVar {
            :bind
            (make-node :clojure/kernel/bind :r_ratio { :name "r" })
            
            :expr
            (make-node :clojure/kernel/lambda :r_p_ratio {
              :params
              (make-node :clojure/kernel/params [
                (make-node :clojure/kernel/bind :c_ratio { :name "c" })
              ])
              
              :body
              (make-node :cf/match2 {
                :expr
                (make-node :clojure/kernel/var {            
                  :ref (ref-node :c_ratio)
                })
                
                :coeff
                (make-node :clojure/kernel/bind :n_ratio { :name "n" })
                
                :cont
                (make-node :clojure/kernel/bind :d_ratio { :name "d" })
                
                :then
                (make-node :clojure/kernel/if {
                  :test
                  (make-node :clojure/core/equal {
                    :left
                    (make-node :clojure/kernel/var {            
                      :ref (ref-node :d_ratio)
                    })
                    
                    :right
                    (make-node :cf/inf)
                  })
                  
                  :then
                  (make-node :clojure/kernel/var {            
                    :ref (ref-node :n_ratio)
                  })
                  
                  :else
                  (make-node :clojure/core/plus {
                    :left
                    (make-node :clojure/kernel/var {            
                      :ref (ref-node :n_ratio)
                    })
                    
                    :right
                    (make-node :clojure/core/fraction {
                      :num
                      (make-node :clojure/kernel/int { :value 1 })
                      
                      :denom
                      (make-node :clojure/kernel/app {
                        :expr
                        (make-node :clojure/kernel/var {            
                          :ref (ref-node :r_p_ratio)
                        })
  
                        :args
                        (make-node :clojure/kernel/args [
                          (make-node :clojure/kernel/var {            
                            :ref (ref-node :d_ratio)
                          })
                        ])
                      })
                    })
                  })
                })
                
                :else
                (make-node :clojure/core/fail)
              })
            })
          })
        ])
      })
    })
  
    ; (make-node :clojure/kernel/quote {
    ;   :body
    ;   (make-node :clojure/kernel/let {
    ;     :bind
    ;     (make-node :clojure/kernel/bind :r_ratio {})
    ;     
    ;     :expr
    ;     (make-node :clojure/kernel/lambda :q_ratio {
    ;       :params
    ;       (make-node :clojure/kernel/params [
    ;         (make-node :clojure/kernel/bind :f_ratio {})
    ;       ])
    ;       
    ;       :body
    ;       ; TODO: use match1/2
    ;       (make-node :clojure/kernel/if {
    ;         :test
    ;         (make-node :clojure/core/has? {
    ;           :node
    ;           (make-node :clojure/kernel/var {
    ;            :ref (ref-node :f_ratio) 
    ;           })
    ;           
    ;           :name
    ;           (make-node :clojure/kernel/name { :value :cont })
    ;         })
    ;           
    ;         ; (make-node :clojure/core/equal {
    ;         ;   :left
    ;         ;   (make-node :clojure/core/type {
    ;         ;     :node
    ;         ;     (make-node :clojure/kernel/var {
    ;         ;      :ref (ref-node :f_ratio) 
    ;         ;     })
    ;         ;   })
    ;         ;   
    ;         ;   :right
    ;         ;   (make-node :clojure/kernel/name { :value :cf/fraction })
    ;         ; })
    ;   
    ;         :then
    ;         (make-node :clojure/core/plus {
    ;           :left
    ;           (make-node :clojure/core/eval {
    ;             :node
    ;             (make-node :cf/coeff {
    ;               :expr
    ;               (make-node :clojure/kernel/var {
    ;                :ref (ref-node :f_ratio) 
    ;               })
    ;             })
    ;           })
    ;           
    ;           :right
    ;           (make-node :clojure/core/fraction {
    ;             :num
    ;             (make-node :clojure/kernel/int { :value 1 })
    ;         
    ;             :denom
    ;             (make-node :clojure/kernel/app {
    ;               :expr
    ;               (make-node :clojure/kernel/var {
    ;                 :ref (ref-node :q_ratio)
    ;               })
    ;               
    ;               :args
    ;               (make-node :clojure/kernel/args [
    ;                 (make-node :cf/cont {
    ;                   :expr
    ;                   (make-node :clojure/kernel/var {
    ;                    :ref (ref-node :f_ratio) 
    ;                   })
    ;                 })
    ;               ])
    ;             })
    ;           })
    ;         })
    ; 
    ;         :else
    ;         (make-node :clojure/core/eval {
    ;           :node
    ;           (make-node :cf/coeff {
    ;             :expr
    ;             (make-node :clojure/kernel/var {
    ;              :ref (ref-node :f_ratio) 
    ;             })
    ;           })
    ;         })
    ;       })
    ;     })
    ;   
    ;     :body
    ;     (make-node :clojure/kernel/app {
    ;       :expr
    ;       (make-node :clojure/kernel/var {
    ;         :ref (ref-node :r_ratio)
    ;       })
    ;       
    ;       :args
    ;       (make-node :clojure/kernel/args [
    ;         (make-node :clojure/kernel/unquote {
    ;           :body
    ;           (make-node :clojure/kernel/var {            
    ;             :ref (ref-node :ratio_expr)
    ;           })
    ;         })
    ;       ])
    ;     })
    ;   })
    ; })
  })
  
  
])