; More examples using the :core language

(use 'meta.core)

(make-node :core/program [
  (make-node :core/doc { :string "Examples using the core syntax for sequences:"})

  ; a couple of cons's:
  (make-node :core/cons {
    :first
    (make-node :kernel/int { :value 1 })
    
    :rest
    (make-node :core/cons {
      :first
      (make-node :kernel/int { :value 2 })
    
      :rest
      (make-node :kernel/nil)
    })
  })
  
  ; a comma-sep. list:
  (make-node :core/list [
    (make-node :kernel/int { :value 1 })
    (make-node :kernel/int { :value 2 })
    (make-node :kernel/int { :value 3 })
  ])
  
  ; first, rest:
  (make-node :kernel/let {
    :bind
    (make-node :kernel/bind :lst {})
    
    :expr
    (make-node :core/list [
      (make-node :kernel/string { :value "a" })
      (make-node :kernel/string { :value "b" })
      (make-node :kernel/string { :value "c" })
    ])
    
    :body
    (make-node :core/list [
      (make-node :core/first {
        :expr
        (make-node :kernel/var {
          :ref (ref-node :lst)
        })
      })
      (make-node :core/first {
        :expr
        (make-node :core/rest {
          :expr
          (make-node :kernel/var {
            :ref (ref-node :lst)
          })
        })
      })
      (make-node :core/nth {
        :expr
        (make-node :kernel/var {
          :ref (ref-node :lst)
        })
        
        :index
        (make-node :kernel/int { :value 2 })
      })
    ])
  })
  
  (make-node :core/doc { :string "Note: f*(x) produces a lazy sequence, and x[i] uses no stack:"})

  ; iterate
  (make-node :kernel/let {
    :bind
    (make-node :kernel/bind :inc_iter {})
    
    :expr
    (make-node :kernel/lambda {  ; TODO: closure syntax
      :params
      (make-node :kernel/params [
        (make-node :kernel/bind :x_iter {})
      ])
      
      :body
      (make-node :core/plus {
        :left
        (make-node :kernel/var {
          :ref (ref-node :x_iter)
        })
        
        :right
        (make-node :kernel/int { :value 1 })
      })
    })
    
    :body
    (make-node :core/nth {
      :expr
      (make-node :core/iterate {
        :fn
        (make-node :kernel/var {
          :ref (ref-node :inc_iter)
        })
      
        :expr
        (make-node :kernel/int { :value 1 })
      })
    
      :index
      (make-node :kernel/int { :value 999999})
    })
  })
    
  ; range:
  (make-node :core/range {
    :min
    (make-node :kernel/int { :value 1 })
    
    :max
    (make-node :kernel/int { :value 10 })
  })
  
      
  ; range + subscript:
  (node :core/nth
    :expr
    (node :core/range
      :min
      (node :core/unaryminus
        :expr
        (node :kernel/int :value 100))
    
      :max
      (node :kernel/int :value 1000000000))
      
    :index
    (node :kernel/int :value 150))
    
  ; for
  (make-node :core/for {
    :x
    (make-node :kernel/bind :x_for { :name "y" })
    
    :seq
    (make-node :core/range {
      :min
      (make-node :kernel/int { :value 1 })
  
      :max
      (make-node :kernel/int { :value 10 })
    })
    
    :expr
    (make-node :core/square {
      :expr
      (make-node :kernel/var {
        :ref (ref-node :x_for)
      })
    })
  })
    
  ; set:
  (make-node :core/in {
    :grammar/binaryNode/right
    (make-node :kernel/int { :value 137 })
    
    :grammar/binaryNode/left
    (make-node :core/set {
      :seq
      (make-node :core/range {
        :min
        (make-node :kernel/int { :value 0 })
        
        :max
        (make-node :kernel/int { :value 99 })
      })
    })
  })
    
  ; set:
  (make-node :core/in {
    :grammar/binaryNode/right
    (make-node :kernel/int { :value 7569 })
    
    :grammar/binaryNode/left
    (make-node :core/set {
      :seq
      (make-node :core/for {
        :x
        (make-node :kernel/bind :z_for { :name "z" })
    
        :seq
        (make-node :core/range {
          :min
          (make-node :kernel/int { :value 1 })
  
          :max
          (make-node :kernel/int { :value 100 })
        })
    
        :expr
        (make-node :core/square {
          :expr
          (make-node :kernel/var {
            :ref (ref-node :z_for)
          })
        })
      })
    })
  })
])
