\section{Presentation}
In any programming language, the \emph{abstract syntax} is primary, and must match the programmer's model of the language. In a textual language, the \emph{concrete syntax} serves as the programmer's way of communicating her intent; effectively she uses the characters of the source code to tell the compiler how to build an AST which expresses the program she wishes to write. This mode of working puts a number of constraints on the concrete syntax. It must be \emph{unambiguous}, so that the compiler never has to make an arbitrary choice of how to interpret the program (and, equally important, so that the programmer can reasonably predict the compiler's interpretation). It must be \emph{simple}, so that the programmer will not be over-burdened with typing. In a narrower sense, it must be \emph{parseable}, using the available parsing algorithms. On the other hand, it must be \emph{readable}, because 



%For a program represented as an AST, the question of \emph{presentation} is separable from the question of syntax. That is, having defined a kernel language and some additional constructs that reduce to it, how should those nodes be made visible to the programmer? In a textual programming language,

%This is the same problem faced by any language designer, often described as ``syntax vs. semantics,'' and novice language designers are often cautioned about confusing the two. Of course, most language designers would argue for the primacy of semantics, but the fact is that language \emph{users} (i.e. programmers) have to deal with syntax and typically understand semantics only imperfectly, and only through the lens of syntax. In this system, the user is more intimately exposed to the actual structure of the program (e.g., its statements and expressions), as opposed to the surface structure (the characters that appear on the screen or page), as the following discussion will show.

\subsection{Concrete syntax}
Once presented with that choice, there are several possibilities. The most direct rendering is to simply render the tree structure of the program. This could take the form of a graph of nodes in a two-dimensional space, connected by edges, as might be produced by a graph-layout tool such as Graphviz\cite{graphviz}. Another direct rendering is to translate nodes into rectangular boxes, with children arranged in vertical lists, similar to the way an XML document or LISP program can be formatted with indentation. These approaches have the advantages of being simple and completely general: because every node is represented the same way, there's no need to define anything special for each new type of node. However, they fail to achieve any of the goals of ??; by being general, they do not provide the best, the most readable, the most compact visual form for each construct. Still, their generality is useful as a fallback, and ?? in fact uses just such a generalized presentation in that way.

Swinging the other way, the system could reduce the nodes of the program to a textual appearance. This is more or less like generating conventional textual source code to be consumed by a compiler, and it's the approach taken by MPS\cite{mps}, for example. In doing so, many of the problems of that kind of source code are reintroduced, and the extra level of indirection is hard to justify.\footnote{As an example, in MPS the equivalent of \clojure{"(* (+ 1 2) 3)"} is rendered as \clojure{"1+2*3"}, exactly the same as the un-equivalent expression \clojure{"(+ 1 (* 2 3))"}. There is no actual ambiguity; the system knows to evaluate the addition subexpression first, and a ``parenthesized expression'' node is available. With that inserted, the expression is rendered unambiguously as\clojure{"(1+2)*3"}. The MPS editor tries to guide the user towards that approach, but it's easy to subvert that guidance, intentionally or otherwise. Thus the burden of coping with ambiguity is ultimately placed on the programmer.}

A richer framework that offers solutions to some of these problems is the notation of mathematics. By combining textual elements with an expanded selection of glyphs and several additional ways of combining them, mathematical notation is able to represent moderately complex expressions with relatively few explicit indicators of grouping (e.g. parentheses). For example, the familiar \emph{quadratic formula}:
$${-b \pm\sqrt{b^2-4ac}} \over 2a$$
requires no parentheses whatsoever, while the equivalent in a conventional language might need at least four pairs: \clojure{(-b + plusOrMinus(sqrt(b*b - 4*a*c))/(2*a)}. This formula makes use of several notational devices which are unavailable in a textual syntax, including a superscript for exponentiation, radical sign for square root, a \emph{vinculum} indicating division, and simple juxtaposition for multiplication. Each of these devices serves two purposes, both indicating a particular operation and at the same time providing a visual indication of grouping\footnote{Indeed, the vinculum was used as an indicator of grouping, as in the expression $\overline{1+2} \times 3$, prior to the use of parentheses\cite{cajori}. The notation for fractions and radical sign (with near-ubiquitous vinculum) are a remnant of this earlier notation.}.

my choice: textual in appearance, but not limited to lines and characters

other requirements: deal with incorrect programs

for other kinds of programs/data, many choices of presentation: word-processor, spreadsheet, flowchart (graphviz)

note: also solves other problems, but not my main focus

\subsection{Principles}
Basic idea: source program is reduced to render-able primitives via a series of reductions.

Inspired by TeX's math mode. Mathematical notation is familiar to all, many problems have been solved already. Use TeX toolset and algorithms.

Every node maps to a rectangular area (box), with children always enclosed by their parent.

Beyond 'layout', some extra features for interactivity built-in.

\subsection{View Language}
Low-level, ready to render. Concepts: section (vbox), sequence (hbox), chars, radical, over, spaces, borders.

Currently rendered by hand-written Clojure/Java2D. Could be (mostly) re-implemented as a reduction to program representing Java2D primitives.

\subsection{Expression Language}
High-level, at language level, minus semantics. Concepts: keyword, var, types of sequences.

\subsection{Extra Help}
Cases where apparent ambiguity is resolved by providing special support in the presentation. The good stuff!

\subsubsection{Names}
All ``names'' unique in the source. Presentation supplies dis-ambiguated, nice form.

\subsubsection{Parenthesization}
\begin{figure}[ht]
$$
\begin{array}{ccc}
% temp: need to use my own output, which will be a better demonstration anyway
\left(1+2\right)\times3 & 
  \mathrm{\it vs.} & 
  1 + 2\times3
\\
\vspace{6pt}
\\
(x+2)^i &
  \mathrm{\it vs.} & 
  x^{i+2}
\\
\vspace{6pt}
\\
(a+b)/2 & 
  \mathrm{\it vs.} & 
  {{a+b} \over 2}
\\
\vspace{6pt}
\\
(y-1)^{1/2} + 2 & 
  \mathrm{\it vs.} & 
  \sqrt{y-1} + 2
\end{array}
$$
\caption{Examples of expressions that require parentheses (on the left), and related expressions where the notation is unambiguous and no parentheses are needed (on the right). Note that in cases where the meaning is equivalent, one or the other form might be preferable from an aesthetic point of view, but the transformation from one to the other is not necessarily trivial (see footnote). All examples are output from ??, with parentheses inserted automatically. \todo{use actual output}}
\label{fig-parens}
\end{figure}

Turning parens around: resolves \emph{superficial} ambiguity, to make the actual, manifest structure apparent\footnote{Knuth in the TeXbook (p.\:140): ``\dots takes a bit of mathematical knowhow, since parentheses sometimes need to be inserted in order to preserve the meaning of the formula...if you are a typist without mathematical training, it's best to ask \dots for help.'' If Knuth had implemented this algorithm, his typists would have been spared this chore. However making the process manual does give the author a greater degree of control, which is probably appropriate in the context of publishing.}. Figure \ref{fig-parens}...



\subsubsection{Quotation}
Makes level of each expression apparent.


\subsection{Reducing to view language}
How the expression language is reduced, as an example of a complex reduction. 

\subsubsection{Modes and levels}

\subsubsection{Missing attributes}

\subsubsection{Unrecognized nodes}
The generalized reduction.