\chapter{Conclusion}

In this thesis, I present tools for defining a language in terms of a grammar for ASTs and reduction to a general-purpose presentation language, as well as a structure editor for any such language. The reductions are written in a new meta-language which is defined in the same way, from syntax extension of a minimal kernel language. The \Meta\ editor provides superior readability of simple programs, plus accurate rendering of mathematical notation. It also eliminates some of the work of entering and modifying programs, offsetting the potential downsides of the structure editing approach.

Moreover, by reducing the difficulty of implementing syntax extensions, and extending the scope of what extensions can do, the system makes the creation of a new language as an extension of a kernel language much simpler and more powerful than before. Much of the work to render and provide editing for language elements is done in a general way, via the presentation language. New languages and new constructs can be specified quite economically as reductions to this language, which provides primitives for the commonly-used visual elements, and can easily be extended with additional symbols.

I believe this expressiveness has the potential to change the way programmers think about their languages. There currently exists a large gulf between what it is possible to do with an ``internal'' DSL (defined in terms of the syntax of the host language) as compared to a ``external'' DSL (for which you have to write a parser, etc.) The former is heavily constrained by the host language's syntax, while the latter is a relatively intimidating project. In \Meta, un-constricted syntax extension allows for much more significant additions the the host language, while its flexibility makes defining a new, separate language much less of a chore. Both options would take advantage of the same tools and methods, making the decision of which way to go much less fraught.

By representing source code in a way that reflects its structure, \Meta\ also makes it much more available for analysis and inspection. Therefore, \Meta\ programs can take the place of the algebraic data types or other data structures commonly used to represent programs inside compilers, static analyzers, and other tools. In many cases where it previously wouldn't have been worth the effort to construct a parser, \Meta\ can provide a rich, readable syntax with very little work. This could be a great help in programming language research and teaching, whenever small languages are defined in the course of exploring some aspect.

One intriguing consequence of \Meta's approach is that the visualization of the program no longer has to be unambiguous. Instead, it can take whatever form is most appropriate to the task at hand. In some cases, as in the continued fraction example, this might mean having symbols on the page which look identical but mean different things. This isn't a problem because the editor knows which is which and can clarify when needed, but it does have one serious implication: when the program is printed out (or captured as a figure for publication), that extra information is thrown away, and \emp{the printout does not actually specify a unique program.} To turn a printout back into source code would involve parsing, which is exactly what \Meta\ scrupulously avoids. However, in \Meta\ you can always address this problem by simply writing a second presentation reduction which is better suited to your current purpose.

As the old joke goes, text is the worst way of representing source code, except for all the others. My hope is that in time we'll get tools that handle trees well enough that we can finally leave text behind.