\section{Implementation}
The preceding discussion was deliberately abstracted from any particular choice of software/hardware platform, concrete representation of nodes, 
\textit{I describe my implementation of these fundamentals, including choice of representation, runtime platform, etc.}


\subsection{Platform and Kernel Language}
The prototype system is implemented in Clojure \cite{hickey}, a language in the LISP family which runs on the Java Virtual Machine \cite{gosling}. Clojure also fills the role of the kernel language. Some characteristics of Clojure that make it a good choice include:
\begin{enumerate}
\item Similar notion of a kernel language. Clojure, like many LISPs (in particular Scheme\cite{dibvig}), is built around a very small set of primitive constructs, or \emph{special forms}. Additional language features are built as syntax extensions on top of the special forms. The prototype simply adopts (a subset of) the special forms of Clojure as its kernel language.
\item Functional orientation. Clojure is a non-pure functional language; it allows side-effects but (in contrast to most LISPs) all of its bindings and data structures are immutable. Destructive assignment is supported only for special \emph{reference} objects which enforce certain semantics (and which do not play any real role in this system). This approach fits quite well with the idea of transformation of immutable trees, and in fact inspired many ideas such as the approach to tree reduction.
\item Compilation service available at runtime. The Clojure compiler is part of the runtime stack, so once a program is reduced to the kernel language, it can be evaluated (compiled) and executed immediately.
\item Access to the Java platform. The prototype takes advantage of Java's GUI toolkit for rendering and editing.
\item Compiles to Java bytecode, and allows direct access to the platform's objects when needed. For example, nodes are represented as instances of a class at the JVM level, which gives excellent performance with no representational overhead. It's some kind of triumph of compiler technology that a program in this system can achieve performance on par with raw C code. \todo{need to prove that?}
\end{enumerate}

\subsubsection{Mapping the kernel language onto Clojure}
The kernel language is defined by 9(?) node types, shown in \ref{fig-kernel}, each corresponding to one of Clojure's special forms or primitive values, plus an \keyword{extern} node which is used to refer to variables at the Clojure level (typically functions from Clojure's runtime). A simple, hand-written function \keyword{meta-compile} transforms a program in this language to the forms (lists, symbols, and other values) of the corresponding Clojure program. These forms are the equivalent of the output of Clojure's \emph{reader}, which is ordinarily responsible for parsing textual source (s-expressions) and turning it into the ``code as data'' that Clojure's compiler operates on. This transformation is trivial for the most part.

Each kernel language node corresponds precisely to a Clojure special form or value, without any additional interpretation. Furthermore the structure of a Clojure program after reading matches the structure of the kernel program precisely: a Clojure program is a tree made from lists where the first element of each list is a symbol which names a special form. For example, the list produced by the reader for the string \clojure{"(+ 1 (* 2 3))"} has exactly the same overall shape as the corresponding kernel language program, with lists replaced by \keyword{app} nodes, and the simple names \clojure{*} and \clojure{+} wrapped in \keyword{extern} nodes. \todo{include a picture of the nodes version? How to do that without going into presentation issues? Can I avoid having tons of pictures of trees?}

A \keyword{bind} node corresponds to a Clojure construct that introduces a name (\clojure{let} or \clojure{fn}), and a \keyword{var} node represents a reference to such a name. This creates the problem of generating suitable names and avoiding conflicts. But this problem is easily solved due to the uniqueness of labels in the ?? program. The meta-compiler simply generates a new name for each label and uses that name for both \keyword{bind} and \keyword{var} nodes.

Once a kernel language program has been meta-compiled, the standard Clojure function \keyword{eval} is invoked, which compiles the expression to Java bytecode, loads it into the running JVM, invokes it, and returns the result as a Clojure/Java value. When necessary a function is available to ``wrap'' that value in (kernel language) nodes which represent the same value. This \emph{unread} mechanism will be discussed later. \todo{Will it? Come back to these implementation details later or not?}


\subsubsection{Compiling quotations}
Two kernel language nodes which do require special handling are the \keyword{quote} and \keyword{unquote} nodes. \todo{}




\subsection{Grammars}


A program is \emph{valid} with respect to a \emph{grammar} if all of its node's types, values, and references comply with certain restrictions imposed by the grammar. A grammar defines the following:
\begin{enumerate}
\item A set of node types which may appear in a valid program.
\item A subset of those node types (often a single type) which may represent the root.
\end{enumerate}

For each node type, a grammar specifies:
\begin{enumerate}
\item Zero or more \emph{abstract types}, which are types for which the type being introduced is an \emph{instance}.
\item Whether the node's value should be an boolean, integer, string, sequence, or map.
\item For integer and string value, some constraints on the particular values that are expected. For example, a node's value might be restricted to positive integers.
\item For a sequence node, the number and (abstract) type of expected child nodes.
\item For a map node, the expected attributes and the (abstract) types of nodes that may inhabit each of them.
\end{enumerate}

\todo{details and example}


